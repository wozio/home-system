<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>YAMI4 - core: yami::core::raw_buffer_data_source Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">YAMI4 - core
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classyami_1_1core_1_1raw__buffer__data__source.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">yami::core::raw_buffer_data_source Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="yami::core::raw_buffer_data_source" --><!-- doxytag: inherits="yami::core::serializable" -->
<p>Serializable wrapper for the raw binary data.  
 <a href="classyami_1_1core_1_1raw__buffer__data__source.html#details">More...</a></p>

<p><code>#include &lt;raw_buffer_data_source.h&gt;</code></p>

<p>Inherits <a class="el" href="classyami_1_1core_1_1serializable.html">yami::core::serializable</a>.</p>

<p><a href="classyami_1_1core_1_1raw__buffer__data__source-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1raw__buffer__data__source.html#a0ddcbd61663a8652175471b149ccd611">raw_buffer_data_source</a> (const char **buffers, const std::size_t *buffer_sizes, std::size_t num_of_buffers)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a0ddcbd61663a8652175471b149ccd611"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1raw__buffer__data__source.html#a9ae192c0adbb925bfb0308ed02dd7422">raw_buffer_data_source</a> (const char *buffer, std::size_t buffer_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a9ae192c0adbb925bfb0308ed02dd7422"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1raw__buffer__data__source.html#a0d27016f8136bb4438fde678cdaf9f01">get_serialize_buffer_size</a> (std::size_t &amp;size) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the total size of serialization buffer.  <a href="#a0d27016f8136bb4438fde678cdaf9f01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1raw__buffer__data__source.html#ac990602a80bbee2cd629b81af66e5eb3">serialize</a> (char **target_buffers, const std::size_t *target_buffer_sizes, std::size_t num_of_target_buffers) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes current content into given buffer(s).  <a href="#ac990602a80bbee2cd629b81af66e5eb3"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Serializable wrapper for the raw binary data allows to use already serialized content for message sending. The two major use cases for this class are efficient message forwarding (when the message is received and its content is used for another message) and support for custom data models and serializers. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0ddcbd61663a8652175471b149ccd611"></a><!-- doxytag: member="yami::core::raw_buffer_data_source::raw_buffer_data_source" ref="a0ddcbd61663a8652175471b149ccd611" args="(const char **buffers, const std::size_t *buffer_sizes, std::size_t num_of_buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_buffer_data_source::raw_buffer_data_source </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t *&#160;</td>
          <td class="paramname"><em>buffer_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_of_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructs the buffer wrapper for the given set of buffers. The data buffer does not have to be contiguous and any number of buffer segments is allowed, provided that the size of each buffer segment is a multiple of 4 (32 bits).<br/>
 The wrapper gathers the binary data from subsequent buffers as they are serialized - serialization of the wrapper copies the data from source set of buffers to the target set, which is possibly structured in a different way.<br/>
 The buffers are provided as array of buffer pointers and their sizes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Pointer to the array of buffer pointers (each of type <code>const char *</code>). </td></tr>
    <tr><td class="paramname">buffer_sizes</td><td>Pointer to the array of buffer sizes. </td></tr>
    <tr><td class="paramname">num_of_buffers</td><td>Number of buffers described by the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ae192c0adbb925bfb0308ed02dd7422"></a><!-- doxytag: member="yami::core::raw_buffer_data_source::raw_buffer_data_source" ref="a9ae192c0adbb925bfb0308ed02dd7422" args="(const char *buffer, std::size_t buffer_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_buffer_data_source::raw_buffer_data_source </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructs the buffer wrapper for the single contiguous source buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to the source buffer. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>Source buffer size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0d27016f8136bb4438fde678cdaf9f01"></a><!-- doxytag: member="yami::core::raw_buffer_data_source::get_serialize_buffer_size" ref="a0d27016f8136bb4438fde678cdaf9f01" args="(std::size_t &amp;size) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> raw_buffer_data_source::get_serialize_buffer_size </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the total size of serialization buffer(s) for the current content of this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The computed size of buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>nesting_too_deep</code> if the level of nesting in this object is deeper than the limit </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="classyami_1_1core_1_1serializable.html#acfb6ba8d9b87789a45f4c213de4908c5">yami::core::serializable</a>.</p>

</div>
</div>
<a class="anchor" id="ac990602a80bbee2cd629b81af66e5eb3"></a><!-- doxytag: member="yami::core::raw_buffer_data_source::serialize" ref="ac990602a80bbee2cd629b81af66e5eb3" args="(char **target_buffers, const std::size_t *target_buffer_sizes, std::size_t num_of_target_buffers) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> raw_buffer_data_source::serialize </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>target_buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t *&#160;</td>
          <td class="paramname"><em>target_buffer_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_of_target_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Serializes the current content of this object into the given buffer(s). The serialization buffer does not have to be contiguous and any number of buffer segments is allowed, provided that the size of each buffer segment is a multiple of 4 (32 bits).<br/>
 The function scatters the serialized data into subsequent buffers as they become filled.<br/>
 The buffers are provided as array of buffer pointers and their sizes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target_buffers</td><td>Pointer to the array of target buffer pointers (each of type <code>char *</code>). </td></tr>
    <tr><td class="paramname">target_buffer_sizes</td><td>Pointer to the array of target buffer sizes. </td></tr>
    <tr><td class="paramname">num_of_target_buffers</td><td>Number of target buffers described by the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>not_enough_space</code> if the buffers are not big enough for all the data </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="classyami_1_1core_1_1serializable.html#a88ac87c424d63cb85ea3de1f46b414d3">yami::core::serializable</a>.</p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceyami.html">yami</a>      </li>
      <li class="navelem"><a class="el" href="namespaceyami_1_1core.html">core</a>      </li>
      <li class="navelem"><a class="el" href="classyami_1_1core_1_1raw__buffer__data__source.html">raw_buffer_data_source</a>      </li>

    <li class="footer">Generated on Tue Aug 6 2013 22:41:04 for YAMI4 - core by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
