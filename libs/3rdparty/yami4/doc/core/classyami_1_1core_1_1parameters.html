<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>YAMI4 - core: yami::core::parameters Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">YAMI4 - core
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classyami_1_1core_1_1parameters.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">yami::core::parameters Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="yami::core::parameters" --><!-- doxytag: inherits="yami::core::serializable" -->
<p>Collection of message parameters.  
 <a href="classyami_1_1core_1_1parameters.html#details">More...</a></p>

<p><code>#include &lt;parameters.h&gt;</code></p>

<p>Inherits <a class="el" href="classyami_1_1core_1_1serializable.html">yami::core::serializable</a>.</p>

<p><a href="classyami_1_1core_1_1parameters-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a37c82fca082181ed65358b1ab78c8158">parameters</a> (void *working_area=NULL, std::size_t area_size=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a37c82fca082181ed65358b1ab78c8158"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a8ef05b5210024cb8d7ab84fddb4d05b2">~parameters</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a8ef05b5210024cb8d7ab84fddb4d05b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#acea3ef2cb89d37f6ed54872e8a4ee58a">set_boolean</a> (const char *name, std::size_t name_length, bool value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type bool.  <a href="#acea3ef2cb89d37f6ed54872e8a4ee58a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#acbdab466dc21100ffe64cf6e1d3823bb">set_boolean</a> (const char *name, bool value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type bool.  <a href="#acbdab466dc21100ffe64cf6e1d3823bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a09b8c7394dc801bfb0e41c7ecd83983f">get_boolean</a> (const char *name, std::size_t name_length, bool &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the bool value from the given entry.  <a href="#a09b8c7394dc801bfb0e41c7ecd83983f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#af1bf27b923011d973808ae69ed2c6882">get_boolean</a> (const char *name, bool &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the bool value from the given entry.  <a href="#af1bf27b923011d973808ae69ed2c6882"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#af8a45ae56602d56e04d2b13d5034681a">set_integer</a> (const char *name, std::size_t name_length, int value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type int.  <a href="#af8a45ae56602d56e04d2b13d5034681a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a3df62a42ac4af1ba2c19051595a44a78">set_integer</a> (const char *name, int value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type int.  <a href="#a3df62a42ac4af1ba2c19051595a44a78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a9e3484f01e82b931a038ec3975d79e4a">get_integer</a> (const char *name, std::size_t name_length, int &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the int value from the given entry.  <a href="#a9e3484f01e82b931a038ec3975d79e4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a12e94105b6c17232ccf5ecb0aeebcebf">get_integer</a> (const char *name, int &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the int value from the given entry.  <a href="#a12e94105b6c17232ccf5ecb0aeebcebf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a9263ff0e7f5807e9e4bd489e20d3ba80">set_long_long</a> (const char *name, std::size_t name_length, long long value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type long long.  <a href="#a9263ff0e7f5807e9e4bd489e20d3ba80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#ac770430c483891ade1dda8993125feeb">set_long_long</a> (const char *name, long long value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type long long.  <a href="#ac770430c483891ade1dda8993125feeb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a81f76f15492bc0f3113ae79b5428bc4c">get_long_long</a> (const char *name, std::size_t name_length, long long &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the long long value from the given entry.  <a href="#a81f76f15492bc0f3113ae79b5428bc4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a428bdc8df526eca3e0da29d94af17967">get_long_long</a> (const char *name, long long &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the long long value from the given entry.  <a href="#a428bdc8df526eca3e0da29d94af17967"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#ad79b265fc55817f5f72b52bfbcd41a27">set_double_float</a> (const char *name, std::size_t name_length, double value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type double.  <a href="#ad79b265fc55817f5f72b52bfbcd41a27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#ab4a6f655fdbebb521d12904d1398fe88">set_double_float</a> (const char *name, double value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type double.  <a href="#ab4a6f655fdbebb521d12904d1398fe88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a7e23bf004a8ef4ac1f98d8d697184022">get_double_float</a> (const char *name, std::size_t name_length, double &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the double value from the given entry.  <a href="#a7e23bf004a8ef4ac1f98d8d697184022"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a82303cbe8aaa08ab1871e964a8408b49">get_double_float</a> (const char *name, double &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the double value from the given entry.  <a href="#a82303cbe8aaa08ab1871e964a8408b49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a8968c6f2c240949e1f9284d315365e9a">set_string</a> (const char *name, std::size_t name_length, const char *value, std::size_t value_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type string.  <a href="#a8968c6f2c240949e1f9284d315365e9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a0a84de7b4ad595f14883179a838adc2d">set_string</a> (const char *name, const char *value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type string.  <a href="#a0a84de7b4ad595f14883179a838adc2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#abb43f1b6109ea37fda914b81e1dcf15a">set_string_shallow</a> (const char *name, std::size_t name_length, const char *value, std::size_t value_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type string.  <a href="#abb43f1b6109ea37fda914b81e1dcf15a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a59a0ad56146fa7ff2fa31f41fc91ab0c">set_string_shallow</a> (const char *name, const char *value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type string.  <a href="#a59a0ad56146fa7ff2fa31f41fc91ab0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a1a450c13f35b2a02c338b76ffb1fdc44">get_string</a> (const char *name, std::size_t name_length, const char *&amp;value, std::size_t &amp;value_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the string value from the given entry.  <a href="#a1a450c13f35b2a02c338b76ffb1fdc44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a75124cee65f7a83cde7717854265bf89">get_string</a> (const char *name, const char *&amp;value, std::size_t &amp;value_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the string value from the given entry.  <a href="#a75124cee65f7a83cde7717854265bf89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a2e26dd403869f570a70a86e11f866bd5">set_binary</a> (const char *name, std::size_t name_length, const void *value, std::size_t value_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type binary.  <a href="#a2e26dd403869f570a70a86e11f866bd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#ac5568dd143a94d4f3da775367da139cd">set_binary</a> (const char *name, const void *value, std::size_t value_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type binary.  <a href="#ac5568dd143a94d4f3da775367da139cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a02a690a73eaab20ada909933d85b3d08">set_binary_shallow</a> (const char *name, std::size_t name_length, const void *value, std::size_t value_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type binary.  <a href="#a02a690a73eaab20ada909933d85b3d08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a664c2cecee38bfddab35edc938315592">set_binary_shallow</a> (const char *name, const void *value, std::size_t value_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type binary.  <a href="#a664c2cecee38bfddab35edc938315592"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a8df2887062ef6a539b5810751587933b">get_binary</a> (const char *name, std::size_t name_length, const void *&amp;value, std::size_t &amp;value_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the binary value from the given entry.  <a href="#a8df2887062ef6a539b5810751587933b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#adf9229add98bd07f47469de41fc8f2f3">get_binary</a> (const char *name, const void *&amp;value, std::size_t &amp;value_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the binary value from the given entry.  <a href="#adf9229add98bd07f47469de41fc8f2f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a59a6846df5b0ba4e300ff3a7a79abb69">set_boolean_array</a> (const char *name, std::size_t name_length, const bool *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type bool array.  <a href="#a59a6846df5b0ba4e300ff3a7a79abb69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#ae94c729dc5390e448d80053c78371a96">set_boolean_array</a> (const char *name, const bool *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type bool array.  <a href="#ae94c729dc5390e448d80053c78371a96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#aa12586e8b12e50332de64e78808e5809">set_boolean_array_shallow</a> (const char *name, std::size_t name_length, const bool *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type bool array.  <a href="#aa12586e8b12e50332de64e78808e5809"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a09f1db479541eef06fa6af2d35901d26">set_boolean_array_shallow</a> (const char *name, const bool *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type bool array.  <a href="#a09f1db479541eef06fa6af2d35901d26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a2c7c72e0e03900e02ec3f346de393a49">create_boolean_array</a> (const char *name, std::size_t name_length, std::size_t array_length, bool *&amp;array)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new uninitialized entry of type bool array.  <a href="#a2c7c72e0e03900e02ec3f346de393a49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a1120ebe092a7be4f03c0c9889e69273b">create_boolean_array</a> (const char *name, std::size_t array_length, bool *&amp;array)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new uninitialized entry of type bool array.  <a href="#a1120ebe092a7be4f03c0c9889e69273b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a8423ff9db0692fb4f569e989a1a293e3">get_boolean_array</a> (const char *name, std::size_t name_length, bool *&amp;values, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the array of bool values from the given entry.  <a href="#a8423ff9db0692fb4f569e989a1a293e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a26db12f323195a5d88a7a7af01283f52">get_boolean_array</a> (const char *name, bool *&amp;values, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the array of bool values from the given entry.  <a href="#a26db12f323195a5d88a7a7af01283f52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#aaf7fb81fcfe1fbafbdba58f13e274bff">set_integer_array</a> (const char *name, std::size_t name_length, const int *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type int array.  <a href="#aaf7fb81fcfe1fbafbdba58f13e274bff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a884d18e5b5fb772e90983911a78c859a">set_integer_array</a> (const char *name, const int *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type int array.  <a href="#a884d18e5b5fb772e90983911a78c859a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a9d177532edfa302593c13cf9cfc8226e">set_integer_array_shallow</a> (const char *name, std::size_t name_length, const int *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type int array.  <a href="#a9d177532edfa302593c13cf9cfc8226e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a94a77dc4a7eb74e74f1c17962d33d303">set_integer_array_shallow</a> (const char *name, const int *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type int array.  <a href="#a94a77dc4a7eb74e74f1c17962d33d303"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#ac6ae253a7590d2104710991052a6dca2">create_integer_array</a> (const char *name, std::size_t name_length, std::size_t array_length, int *&amp;array)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new uninitialized entry of type int array.  <a href="#ac6ae253a7590d2104710991052a6dca2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a950512097c8d45a1ed60d5c3184c105a">create_integer_array</a> (const char *name, std::size_t array_length, int *&amp;array)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new uninitialized entry of type int array.  <a href="#a950512097c8d45a1ed60d5c3184c105a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a165f4ec95699f7dd3bb339c0e5ebfaf2">get_integer_array</a> (const char *name, std::size_t name_length, int *&amp;values, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the array of int values from the given entry.  <a href="#a165f4ec95699f7dd3bb339c0e5ebfaf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a10872e8393b3d4d6201cec655cad1c8e">get_integer_array</a> (const char *name, int *&amp;values, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the array of int values from the given entry.  <a href="#a10872e8393b3d4d6201cec655cad1c8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#aab0cdea54b330bb9990abb81e22eea51">set_long_long_array</a> (const char *name, std::size_t name_length, const long long *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type long long array.  <a href="#aab0cdea54b330bb9990abb81e22eea51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#aa2c828ad8b803a18911c3346ee85a149">set_long_long_array</a> (const char *name, const long long *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type long long array.  <a href="#aa2c828ad8b803a18911c3346ee85a149"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a0ed01134af667a61bc2520683201412b">set_long_long_array_shallow</a> (const char *name, std::size_t name_length, const long long *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type long long array.  <a href="#a0ed01134af667a61bc2520683201412b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a1f0e50aada865f8300cff955bb074d10">set_long_long_array_shallow</a> (const char *name, const long long *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type long long array.  <a href="#a1f0e50aada865f8300cff955bb074d10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a1fa4ff403b41016d1bf052c917e703cb">create_long_long_array</a> (const char *name, std::size_t name_length, std::size_t array_length, long long *&amp;array)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new uninitialized entry of type long long array.  <a href="#a1fa4ff403b41016d1bf052c917e703cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a0e1fdf26ff84a35363aaf6b64d324663">create_long_long_array</a> (const char *name, std::size_t array_length, long long *&amp;array)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new uninitialized entry of type long long array.  <a href="#a0e1fdf26ff84a35363aaf6b64d324663"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#aaf5e9bfeb6a4bcea7ec7ab40080f54a1">get_long_long_array</a> (const char *name, std::size_t name_length, long long *&amp;values, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the array of long long values from the given entry.  <a href="#aaf5e9bfeb6a4bcea7ec7ab40080f54a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a56e2d46ea21a57f4a6f5cc2fe5ad90b0">get_long_long_array</a> (const char *name, long long *&amp;values, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the array of long long values from the given entry.  <a href="#a56e2d46ea21a57f4a6f5cc2fe5ad90b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a033d5ecc0d16c2bcfff126675bf677a4">set_double_float_array</a> (const char *name, std::size_t name_length, const double *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type double array.  <a href="#a033d5ecc0d16c2bcfff126675bf677a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a2f89f8cb5e3981dc271147d7bbb30bd0">set_double_float_array</a> (const char *name, const double *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type double array.  <a href="#a2f89f8cb5e3981dc271147d7bbb30bd0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#ac52b9d03ad90a6387aa0892888cd94b0">set_double_float_array_shallow</a> (const char *name, std::size_t name_length, const double *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type double array.  <a href="#ac52b9d03ad90a6387aa0892888cd94b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a519fb117e3795f57f2552a9b38f2613a">set_double_float_array_shallow</a> (const char *name, const double *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type double array.  <a href="#a519fb117e3795f57f2552a9b38f2613a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a33d489e753d53ac5bc28a13d767ca009">create_double_float_array</a> (const char *name, std::size_t name_length, std::size_t array_length, double *&amp;array)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new uninitialized entry of type double float array.  <a href="#a33d489e753d53ac5bc28a13d767ca009"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a4b7b035ac629bcb555840933ec4042ff">create_double_float_array</a> (const char *name, std::size_t array_length, double *&amp;array)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new uninitialized entry of type double float array.  <a href="#a4b7b035ac629bcb555840933ec4042ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#ae3923e37649e834d8344b2152fb364ec">get_double_float_array</a> (const char *name, std::size_t name_length, double *&amp;values, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the array of double values from the given entry.  <a href="#ae3923e37649e834d8344b2152fb364ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a2ce30504a370021a5e977b425f65d24f">get_double_float_array</a> (const char *name, double *&amp;values, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the array of double values from the given entry.  <a href="#a2ce30504a370021a5e977b425f65d24f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a7c8413fe178527602b866fded1ea1a2b">create_string_array</a> (const char *name, std::size_t name_length, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new empty entry of type string array.  <a href="#a7c8413fe178527602b866fded1ea1a2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a83dbc0d4b62ee9a0228e6d878107a816">create_string_array</a> (const char *name, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new empty entry of type string array.  <a href="#a83dbc0d4b62ee9a0228e6d878107a816"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#aca27b8950c6ca517757342071761e447">set_string_in_array</a> (const char *name, std::size_t name_length, std::size_t index, const char *value, std::size_t value_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new string value to string array.  <a href="#aca27b8950c6ca517757342071761e447"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#aef0cd412b1851b6f92cdc57964213a61">set_string_in_array</a> (const char *name, std::size_t index, const char *value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new string value to string array.  <a href="#aef0cd412b1851b6f92cdc57964213a61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a5001ec4a9ab586b2cb116f5c4f45ab40">get_string_array_length</a> (const char *name, std::size_t name_length, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the length of string array.  <a href="#a5001ec4a9ab586b2cb116f5c4f45ab40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a75ab7f43752f4851196682b1faeee7aa">get_string_array_length</a> (const char *name, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the length of string array.  <a href="#a75ab7f43752f4851196682b1faeee7aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#ab58a99b573ebd504c8f32a909adcb3b8">get_string_in_array</a> (const char *name, std::size_t name_length, std::size_t index, const char *&amp;value, std::size_t &amp;value_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts string value from string array.  <a href="#ab58a99b573ebd504c8f32a909adcb3b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#adb32bbb30df0d9a5acf3b9fca453b861">get_string_in_array</a> (const char *name, std::size_t index, const char *&amp;value, std::size_t &amp;value_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts string value from string array.  <a href="#adb32bbb30df0d9a5acf3b9fca453b861"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#afc8c15e49031c8a4f7d8e2045f3b5f10">create_binary_array</a> (const char *name, std::size_t name_length, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new empty entry of type binary array.  <a href="#afc8c15e49031c8a4f7d8e2045f3b5f10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a150eb36ba477d31a3758648260ee3f39">create_binary_array</a> (const char *name, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new empty entry of type binary array.  <a href="#a150eb36ba477d31a3758648260ee3f39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a33b801ce13e69fb4b08aa29e603da8a7">set_binary_in_array</a> (const char *name, std::size_t name_length, std::size_t index, const void *value, std::size_t value_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new binary value to binary array.  <a href="#a33b801ce13e69fb4b08aa29e603da8a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#ade03cf2869b3d34dc1c0ae06ad685aca">set_binary_in_array</a> (const char *name, std::size_t index, const void *value, std::size_t value_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new binary value to binary array.  <a href="#ade03cf2869b3d34dc1c0ae06ad685aca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#adc0bd21862b51348ea361a7d3a7912fd">get_binary_array_length</a> (const char *name, std::size_t name_length, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the length of binary array.  <a href="#adc0bd21862b51348ea361a7d3a7912fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a2742d6e720689f0cdd15c352d6159c68">get_binary_array_length</a> (const char *name, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the length of binary array.  <a href="#a2742d6e720689f0cdd15c352d6159c68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#aca4d63b81afa196b2128901762e54d41">get_binary_in_array</a> (const char *name, std::size_t name_length, std::size_t index, const void *&amp;value, std::size_t &amp;value_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts binary value from binary array.  <a href="#aca4d63b81afa196b2128901762e54d41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a88bc7ae6c77d4d19d62b0d1bf7928cac">get_binary_in_array</a> (const char *name, std::size_t index, const void *&amp;value, std::size_t &amp;value_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts binary value from binary array.  <a href="#a88bc7ae6c77d4d19d62b0d1bf7928cac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a57e1e33b2fa00c531ab61bfd18ab9cca">create_nested_parameters</a> (const char *name, std::size_t name_length, <a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> *&amp;params)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates nested parameters entry.  <a href="#a57e1e33b2fa00c531ab61bfd18ab9cca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a5dc5a2d159295179cae3273e29391e29">create_nested_parameters</a> (const char *name, <a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> *&amp;params)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates nested parameters entry.  <a href="#a5dc5a2d159295179cae3273e29391e29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#ae8cdbcee3fce9ded6dd37c058c29b43e">get_nested_parameters</a> (const char *name, std::size_t name_length, <a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> *&amp;params) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the nested parameters object from the given entry.  <a href="#ae8cdbcee3fce9ded6dd37c058c29b43e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a86f0901b6dfec2d54f2569c2bc6e2706">get_nested_parameters</a> (const char *name, <a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> *&amp;params) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the nested parameters object from the given entry.  <a href="#a86f0901b6dfec2d54f2569c2bc6e2706"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a4fbf9d95e811baa47d88f2ed3f806524">create_nested_array</a> (const char *name, std::size_t name_length, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new empty entry of type nested parameters array.  <a href="#a4fbf9d95e811baa47d88f2ed3f806524"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#af165ff9ef48ff57081881dc655df8237">create_nested_array</a> (const char *name, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new empty entry of type nested parameters array.  <a href="#af165ff9ef48ff57081881dc655df8237"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a6adf6d057c46a4ffe919eb621bd8ad1e">get_nested_array_length</a> (const char *name, std::size_t name_length, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the length of nested parameters array.  <a href="#a6adf6d057c46a4ffe919eb621bd8ad1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#afcde131182b7e49fa01c52c063b2f0ed">get_nested_array_length</a> (const char *name, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the length of nested parameters array.  <a href="#afcde131182b7e49fa01c52c063b2f0ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#af6f4fe7a2b23f7c61c27237f22a9d37b">get_nested_in_array</a> (const char *name, std::size_t name_length, std::size_t index, <a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> *&amp;nested) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts nested parameters value from nested array.  <a href="#af6f4fe7a2b23f7c61c27237f22a9d37b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a8cd8220ce73281d6c7d36e4a930ac90b">get_nested_in_array</a> (const char *name, std::size_t index, <a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> *&amp;nested) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts nested parameters value from nested array.  <a href="#a8cd8220ce73281d6c7d36e4a930ac90b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#abbe7b8d803185b29785c0b455deab01b">remove</a> (const char *name, std::size_t name_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given entry.  <a href="#abbe7b8d803185b29785c0b455deab01b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a1ecebb2d4c153937de705342cd43a57e">remove</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given entry.  <a href="#a1ecebb2d4c153937de705342cd43a57e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a1b53aa1d01977889db4bff9159f8589a">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the collection.  <a href="#a1b53aa1d01977889db4bff9159f8589a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a5058088c67d4d1a48583f195f8a45079">get_type</a> (const char *name, std::size_t name_length, <a class="el" href="namespaceyami_1_1core.html#ae96e9976f39b4cd83de6301a9581f7b9">parameter_type</a> &amp;t) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the type of the given entry.  <a href="#a5058088c67d4d1a48583f195f8a45079"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#ad6c336e24e6d54c9aeb58cd59e81f9f7">get_type</a> (const char *name, <a class="el" href="namespaceyami_1_1core.html#ae96e9976f39b4cd83de6301a9581f7b9">parameter_type</a> &amp;t) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the type of the given entry.  <a href="#ad6c336e24e6d54c9aeb58cd59e81f9f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a82553546168790a6dd55682a21a4bb64">get_iterator</a> (<a class="el" href="classyami_1_1core_1_1parameter__iterator.html">parameter_iterator</a> &amp;it) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the iterator to all entries.  <a href="#a82553546168790a6dd55682a21a4bb64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a95254a2f00520ae9f145d73fc7e9c6f8">find</a> (const char *name, std::size_t name_length, <a class="el" href="classyami_1_1core_1_1parameter__entry.html">parameter_entry</a> &amp;entry) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the given entry.  <a href="#a95254a2f00520ae9f145d73fc7e9c6f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a0fcde08e589e7029166f1e5f8b7ce256">find</a> (const char *name, <a class="el" href="classyami_1_1core_1_1parameter__entry.html">parameter_entry</a> &amp;entry) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the given entry.  <a href="#a0fcde08e589e7029166f1e5f8b7ce256"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a85f5f0cd7903926ecbd34d0d7e8786eb">merge_from</a> (const <a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges entries from the given parameters object.  <a href="#a85f5f0cd7903926ecbd34d0d7e8786eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a893060f7227a52e9fa9f459b30045773">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the collection of entries.  <a href="#a893060f7227a52e9fa9f459b30045773"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a4ade3419d33fdabed528ab2dc64d4745">get_serialize_buffer_size</a> (std::size_t &amp;size) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the total size of serialization buffer.  <a href="#a4ade3419d33fdabed528ab2dc64d4745"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a015d9e9667737105f69733cf5fd21ac8">serialize</a> (char **buffers, const std::size_t *buffer_sizes, std::size_t num_of_buffers) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes current content into given buffer(s).  <a href="#a015d9e9667737105f69733cf5fd21ac8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1parameters.html#a00c914958c70a6c2b44b9dac3c81eb83">deserialize</a> (const char **buffers, const std::size_t *buffer_sizes, std::size_t num_of_buffers)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes from the given buffer(s).  <a href="#a00c914958c70a6c2b44b9dac3c81eb83"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The collection of message parameters, which are typed {name, value} pairs.</p>
<p>Each entry in this collection has a unique name and can have one of the following types:</p>
<ul>
<li>bool or bool array</li>
<li>int or int array</li>
<li>long long or long long array</li>
<li>double or double array</li>
<li>string or string array</li>
<li>binary or binary array</li>
<li>nested parameters object, which provides its own scope for naming.</li>
</ul>
<p>Each entry has a name that can be either null-terminated or contain embedded zeros and appropriate member functions are provided for both cases. The names are searched for using case-sensitive comparisons. The name of entry is always kept by copy.</p>
<p>This class is not copyable and not thread-safe, although distinct instances of this class can be used by different threads without synchronization.</p>
<p><b>Note:</b> The entries are <em>ordered</em> - the order in which they are created influences the final serialized form of the message payload.<br/>
 Newly created entries are appended to the end of the collection unless there is an existing empty slot that can be reused - the appropriate slot is searched for from the beginning to the end of the collection and if no free slot is found the collection is extended at the end.<br/>
 The above guarantee concerns the user code that relies on predictable serialization. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a37c82fca082181ed65358b1ab78c8158"></a><!-- doxytag: member="yami::core::parameters::parameters" ref="a37c82fca082181ed65358b1ab78c8158" args="(void *working_area=NULL, std::size_t area_size=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parameters::parameters </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>working_area</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>area_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates an empty parameters object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">working_area</td><td>If not NULL, forces this object to use the given area for all private storage. </td></tr>
    <tr><td class="paramname">area_size</td><td>If different than 0, indicates the size of the private memory area that will be used for all dependent structures.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Notes:</b></p>
<ul>
<li>If <code>working_area == NULL &amp;&amp; area_size == 0</code> (the default) then all dependent objects are separately allocated on the global store.</li>
<li>If <code>working_area != NULL &amp;&amp; area_size != 0</code> then the given block is used as a private area.</li>
</ul>
<p><b>Note:</b> Do not attempt to create objects sharing the same working area. </p>

</div>
</div>
<a class="anchor" id="a8ef05b5210024cb8d7ab84fddb4d05b2"></a><!-- doxytag: member="yami::core::parameters::~parameters" ref="a8ef05b5210024cb8d7ab84fddb4d05b2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parameters::~parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The destructor cleans all dependent resources <em>only</em> if each of them was separately allocated on the global store. If the parameters object was created with externally provided working area (that is, when <code>working_area != NULL</code> when the object was constructed) then no cleanup is performed. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acea3ef2cb89d37f6ed54872e8a4ee58a"></a><!-- doxytag: member="yami::core::parameters::set_boolean" ref="acea3ef2cb89d37f6ed54872e8a4ee58a" args="(const char *name, std::size_t name_length, bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_boolean </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type bool to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="acbdab466dc21100ffe64cf6e1d3823bb"></a><!-- doxytag: member="yami::core::parameters::set_boolean" ref="acbdab466dc21100ffe64cf6e1d3823bb" args="(const char *name, bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_boolean </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type bool with null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a09b8c7394dc801bfb0e41c7ecd83983f"></a><!-- doxytag: member="yami::core::parameters::get_boolean" ref="a09b8c7394dc801bfb0e41c7ecd83983f" args="(const char *name, std::size_t name_length, bool &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_boolean </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the bool value from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the given entry does not contain bool</li>
<li><code>no_such_name</code> if the given name cannot be found </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af1bf27b923011d973808ae69ed2c6882"></a><!-- doxytag: member="yami::core::parameters::get_boolean" ref="af1bf27b923011d973808ae69ed2c6882" args="(const char *name, bool &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_boolean </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the bool value from the entry given by null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="af8a45ae56602d56e04d2b13d5034681a"></a><!-- doxytag: member="yami::core::parameters::set_integer" ref="af8a45ae56602d56e04d2b13d5034681a" args="(const char *name, std::size_t name_length, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_integer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type int to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a3df62a42ac4af1ba2c19051595a44a78"></a><!-- doxytag: member="yami::core::parameters::set_integer" ref="a3df62a42ac4af1ba2c19051595a44a78" args="(const char *name, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_integer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type int with null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a9e3484f01e82b931a038ec3975d79e4a"></a><!-- doxytag: member="yami::core::parameters::get_integer" ref="a9e3484f01e82b931a038ec3975d79e4a" args="(const char *name, std::size_t name_length, int &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_integer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the int value from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the given entry does not contain int</li>
<li><code>no_such_name</code> if the given name cannot be found </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a12e94105b6c17232ccf5ecb0aeebcebf"></a><!-- doxytag: member="yami::core::parameters::get_integer" ref="a12e94105b6c17232ccf5ecb0aeebcebf" args="(const char *name, int &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_integer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the int value from the entry given by null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a9263ff0e7f5807e9e4bd489e20d3ba80"></a><!-- doxytag: member="yami::core::parameters::set_long_long" ref="a9263ff0e7f5807e9e4bd489e20d3ba80" args="(const char *name, std::size_t name_length, long long value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_long_long </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type long long to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac770430c483891ade1dda8993125feeb"></a><!-- doxytag: member="yami::core::parameters::set_long_long" ref="ac770430c483891ade1dda8993125feeb" args="(const char *name, long long value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_long_long </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type long long with null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a81f76f15492bc0f3113ae79b5428bc4c"></a><!-- doxytag: member="yami::core::parameters::get_long_long" ref="a81f76f15492bc0f3113ae79b5428bc4c" args="(const char *name, std::size_t name_length, long long &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_long_long </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the long long value from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the given entry does not contain long long</li>
<li><code>no_such_name</code> if the given name cannot be found </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a428bdc8df526eca3e0da29d94af17967"></a><!-- doxytag: member="yami::core::parameters::get_long_long" ref="a428bdc8df526eca3e0da29d94af17967" args="(const char *name, long long &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_long_long </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the long long value from the entry given by null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="ad79b265fc55817f5f72b52bfbcd41a27"></a><!-- doxytag: member="yami::core::parameters::set_double_float" ref="ad79b265fc55817f5f72b52bfbcd41a27" args="(const char *name, std::size_t name_length, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_double_float </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type double to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab4a6f655fdbebb521d12904d1398fe88"></a><!-- doxytag: member="yami::core::parameters::set_double_float" ref="ab4a6f655fdbebb521d12904d1398fe88" args="(const char *name, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_double_float </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type double with null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a7e23bf004a8ef4ac1f98d8d697184022"></a><!-- doxytag: member="yami::core::parameters::get_double_float" ref="a7e23bf004a8ef4ac1f98d8d697184022" args="(const char *name, std::size_t name_length, double &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_double_float </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the double value from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the given entry does not contain double</li>
<li><code>no_such_name</code> if the given name cannot be found </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a82303cbe8aaa08ab1871e964a8408b49"></a><!-- doxytag: member="yami::core::parameters::get_double_float" ref="a82303cbe8aaa08ab1871e964a8408b49" args="(const char *name, double &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_double_float </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the double value from the entry given by null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a8968c6f2c240949e1f9284d315365e9a"></a><!-- doxytag: member="yami::core::parameters::set_string" ref="a8968c6f2c240949e1f9284d315365e9a" args="(const char *name, std::size_t name_length, const char *value, std::size_t value_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type string to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the value buffer to be set. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">value_length</td><td>Length of the value buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
</ul>
</dd></dl>
<p><b>Note:</b> The value is <em>copied</em> to the internal buffer. </p>

</div>
</div>
<a class="anchor" id="a0a84de7b4ad595f14883179a838adc2d"></a><!-- doxytag: member="yami::core::parameters::set_string" ref="a0a84de7b4ad595f14883179a838adc2d" args="(const char *name, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type string with null-terminated name and value. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="abb43f1b6109ea37fda914b81e1dcf15a"></a><!-- doxytag: member="yami::core::parameters::set_string_shallow" ref="abb43f1b6109ea37fda914b81e1dcf15a" args="(const char *name, std::size_t name_length, const char *value, std::size_t value_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_string_shallow </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type string to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the value buffer to be set. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">value_length</td><td>Length of the value buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
</ul>
</dd></dl>
<p><b>Note:</b> The value is <em><b>not</b></em> <em>copied</em> to the internal buffer and the user has to ensure that the given buffer is valid as long as this object refers to it. </p>

</div>
</div>
<a class="anchor" id="a59a0ad56146fa7ff2fa31f41fc91ab0c"></a><!-- doxytag: member="yami::core::parameters::set_string_shallow" ref="a59a0ad56146fa7ff2fa31f41fc91ab0c" args="(const char *name, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_string_shallow </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts (without copy) a new entry of type string with null-terminated name and value. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a1a450c13f35b2a02c338b76ffb1fdc44"></a><!-- doxytag: member="yami::core::parameters::get_string" ref="a1a450c13f35b2a02c338b76ffb1fdc44" args="(const char *name, std::size_t name_length, const char *&amp;value, std::size_t &amp;value_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the string value from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the internal value buffer to be returned. </td></tr>
    <tr><td class="paramname">value_length</td><td>Length of the internal value buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the given entry does not contain string</li>
<li><code>no_such_name</code> if the given name cannot be found </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a75124cee65f7a83cde7717854265bf89"></a><!-- doxytag: member="yami::core::parameters::get_string" ref="a75124cee65f7a83cde7717854265bf89" args="(const char *name, const char *&amp;value, std::size_t &amp;value_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the string value from the entry given by null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a2e26dd403869f570a70a86e11f866bd5"></a><!-- doxytag: member="yami::core::parameters::set_binary" ref="a2e26dd403869f570a70a86e11f866bd5" args="(const char *name, std::size_t name_length, const void *value, std::size_t value_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_binary </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type binary to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the value buffer to be set. </td></tr>
    <tr><td class="paramname">value_length</td><td>Length of the value buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
</ul>
</dd></dl>
<p><b>Note:</b> The value is <em>copied</em> to the internal buffer. </p>

</div>
</div>
<a class="anchor" id="ac5568dd143a94d4f3da775367da139cd"></a><!-- doxytag: member="yami::core::parameters::set_binary" ref="ac5568dd143a94d4f3da775367da139cd" args="(const char *name, const void *value, std::size_t value_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_binary </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type binary with null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a02a690a73eaab20ada909933d85b3d08"></a><!-- doxytag: member="yami::core::parameters::set_binary_shallow" ref="a02a690a73eaab20ada909933d85b3d08" args="(const char *name, std::size_t name_length, const void *value, std::size_t value_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_binary_shallow </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type binary to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the value buffer to be set. </td></tr>
    <tr><td class="paramname">value_length</td><td>Length of the value buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
</ul>
</dd></dl>
<p><b>Note:</b> The value is <em><b>not</b></em> <em>copied</em> to the internal buffer and the user has to ensure that the given buffer is valid as long as this object refers to it. </p>

</div>
</div>
<a class="anchor" id="a664c2cecee38bfddab35edc938315592"></a><!-- doxytag: member="yami::core::parameters::set_binary_shallow" ref="a664c2cecee38bfddab35edc938315592" args="(const char *name, const void *value, std::size_t value_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_binary_shallow </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts (without copy) a new entry of type binary with null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a8df2887062ef6a539b5810751587933b"></a><!-- doxytag: member="yami::core::parameters::get_binary" ref="a8df2887062ef6a539b5810751587933b" args="(const char *name, std::size_t name_length, const void *&amp;value, std::size_t &amp;value_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_binary </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the binary value from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the internal value buffer to be returned. </td></tr>
    <tr><td class="paramname">value_length</td><td>Length of the internal value buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the given entry does not contain binary</li>
<li><code>no_such_name</code> if the given name cannot be found </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="adf9229add98bd07f47469de41fc8f2f3"></a><!-- doxytag: member="yami::core::parameters::get_binary" ref="adf9229add98bd07f47469de41fc8f2f3" args="(const char *name, const void *&amp;value, std::size_t &amp;value_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_binary </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the binary value from the entry given by null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a59a6846df5b0ba4e300ff3a7a79abb69"></a><!-- doxytag: member="yami::core::parameters::set_boolean_array" ref="a59a6846df5b0ba4e300ff3a7a79abb69" args="(const char *name, std::size_t name_length, const bool *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_boolean_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type bool array to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the array of values to be set. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
</ul>
</dd></dl>
<p><b>Note:</b> The array of values is <em>copied</em> to the internal buffer. </p>

</div>
</div>
<a class="anchor" id="ae94c729dc5390e448d80053c78371a96"></a><!-- doxytag: member="yami::core::parameters::set_boolean_array" ref="ae94c729dc5390e448d80053c78371a96" args="(const char *name, const bool *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_boolean_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type bool array with null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="aa12586e8b12e50332de64e78808e5809"></a><!-- doxytag: member="yami::core::parameters::set_boolean_array_shallow" ref="aa12586e8b12e50332de64e78808e5809" args="(const char *name, std::size_t name_length, const bool *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_boolean_array_shallow </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type bool array to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the array of values to be set. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
</ul>
</dd></dl>
<p><b>Note:</b> The array of values is <em><b>not</b></em> <em>copied</em> to the internal buffer and the user has to ensure that the given buffer is valid as long as this object refers to it. </p>

</div>
</div>
<a class="anchor" id="a09f1db479541eef06fa6af2d35901d26"></a><!-- doxytag: member="yami::core::parameters::set_boolean_array_shallow" ref="a09f1db479541eef06fa6af2d35901d26" args="(const char *name, const bool *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_boolean_array_shallow </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts (without copy) a new entry of type bool array with null-terminated name and value. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a2c7c72e0e03900e02ec3f346de393a49"></a><!-- doxytag: member="yami::core::parameters::create_boolean_array" ref="a2c7c72e0e03900e02ec3f346de393a49" args="(const char *name, std::size_t name_length, std::size_t array_length, bool *&amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::create_boolean_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new entry of type bool array in the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the new array. </td></tr>
    <tr><td class="paramname">array</td><td>Returned pointer to the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1120ebe092a7be4f03c0c9889e69273b"></a><!-- doxytag: member="yami::core::parameters::create_boolean_array" ref="a1120ebe092a7be4f03c0c9889e69273b" args="(const char *name, std::size_t array_length, bool *&amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::create_boolean_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new entry of type bool array with null-terminated name and given length. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a8423ff9db0692fb4f569e989a1a293e3"></a><!-- doxytag: member="yami::core::parameters::get_boolean_array" ref="a8423ff9db0692fb4f569e989a1a293e3" args="(const char *name, std::size_t name_length, bool *&amp;values, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_boolean_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the array of bool values from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the internal array buffer to be returned. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the internal array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the given entry does not contain bool array</li>
<li><code>no_such_name</code> if the given name cannot be found</li>
</ul>
</dd></dl>
<p><b>Note:</b> this function gives read-write access to the underlying array, even if it was set as a shallow-copy. </p>

</div>
</div>
<a class="anchor" id="a26db12f323195a5d88a7a7af01283f52"></a><!-- doxytag: member="yami::core::parameters::get_boolean_array" ref="a26db12f323195a5d88a7a7af01283f52" args="(const char *name, bool *&amp;values, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_boolean_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the array of bool values from the entry given by null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="aaf7fb81fcfe1fbafbdba58f13e274bff"></a><!-- doxytag: member="yami::core::parameters::set_integer_array" ref="aaf7fb81fcfe1fbafbdba58f13e274bff" args="(const char *name, std::size_t name_length, const int *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_integer_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type int array to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the array of values to be set. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
</ul>
</dd></dl>
<p><b>Note:</b> The array of values is <em>copied</em> to the internal buffer. </p>

</div>
</div>
<a class="anchor" id="a884d18e5b5fb772e90983911a78c859a"></a><!-- doxytag: member="yami::core::parameters::set_integer_array" ref="a884d18e5b5fb772e90983911a78c859a" args="(const char *name, const int *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_integer_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type int array with null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a9d177532edfa302593c13cf9cfc8226e"></a><!-- doxytag: member="yami::core::parameters::set_integer_array_shallow" ref="a9d177532edfa302593c13cf9cfc8226e" args="(const char *name, std::size_t name_length, const int *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_integer_array_shallow </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type int array to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the array of values to be set. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
</ul>
</dd></dl>
<p><b>Note:</b> The array of values is <em><b>not</b></em> <em>copied</em> to the internal buffer and the user has to ensure that the given buffer is valid as long as this object refers to it. </p>

</div>
</div>
<a class="anchor" id="a94a77dc4a7eb74e74f1c17962d33d303"></a><!-- doxytag: member="yami::core::parameters::set_integer_array_shallow" ref="a94a77dc4a7eb74e74f1c17962d33d303" args="(const char *name, const int *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_integer_array_shallow </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts (without copy) a new entry of type int array with null-terminated name and value. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="ac6ae253a7590d2104710991052a6dca2"></a><!-- doxytag: member="yami::core::parameters::create_integer_array" ref="ac6ae253a7590d2104710991052a6dca2" args="(const char *name, std::size_t name_length, std::size_t array_length, int *&amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::create_integer_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new entry of type int array in the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the new array. </td></tr>
    <tr><td class="paramname">array</td><td>Returned pointer to the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a950512097c8d45a1ed60d5c3184c105a"></a><!-- doxytag: member="yami::core::parameters::create_integer_array" ref="a950512097c8d45a1ed60d5c3184c105a" args="(const char *name, std::size_t array_length, int *&amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::create_integer_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new entry of type int array with null-terminated name and given length. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a165f4ec95699f7dd3bb339c0e5ebfaf2"></a><!-- doxytag: member="yami::core::parameters::get_integer_array" ref="a165f4ec95699f7dd3bb339c0e5ebfaf2" args="(const char *name, std::size_t name_length, int *&amp;values, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_integer_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the array of int values from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the internal array buffer to be returned. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the internal array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the given entry does not contain int array</li>
<li><code>no_such_name</code> if the given name cannot be found</li>
</ul>
</dd></dl>
<p><b>Note:</b> this function gives read-write access to the underlying array, even if it was set as a shallow-copy. </p>

</div>
</div>
<a class="anchor" id="a10872e8393b3d4d6201cec655cad1c8e"></a><!-- doxytag: member="yami::core::parameters::get_integer_array" ref="a10872e8393b3d4d6201cec655cad1c8e" args="(const char *name, int *&amp;values, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_integer_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the array of int values from the entry given by null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="aab0cdea54b330bb9990abb81e22eea51"></a><!-- doxytag: member="yami::core::parameters::set_long_long_array" ref="aab0cdea54b330bb9990abb81e22eea51" args="(const char *name, std::size_t name_length, const long long *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_long_long_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type long long array to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the array of values to be set. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
</ul>
</dd></dl>
<p><b>Note:</b> The array of values is <em>copied</em> to the internal buffer. </p>

</div>
</div>
<a class="anchor" id="aa2c828ad8b803a18911c3346ee85a149"></a><!-- doxytag: member="yami::core::parameters::set_long_long_array" ref="aa2c828ad8b803a18911c3346ee85a149" args="(const char *name, const long long *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_long_long_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type long long array with null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a0ed01134af667a61bc2520683201412b"></a><!-- doxytag: member="yami::core::parameters::set_long_long_array_shallow" ref="a0ed01134af667a61bc2520683201412b" args="(const char *name, std::size_t name_length, const long long *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_long_long_array_shallow </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type long long array to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the array of values to be set. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
</ul>
</dd></dl>
<p><b>Note:</b> The array of values is <em><b>not</b></em> <em>copied</em> to the internal buffer and the user has to ensure that the given buffer is valid as long as this object refers to it. </p>

</div>
</div>
<a class="anchor" id="a1f0e50aada865f8300cff955bb074d10"></a><!-- doxytag: member="yami::core::parameters::set_long_long_array_shallow" ref="a1f0e50aada865f8300cff955bb074d10" args="(const char *name, const long long *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_long_long_array_shallow </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts (without copy) a new entry of type long long array with null-terminated name and value. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a1fa4ff403b41016d1bf052c917e703cb"></a><!-- doxytag: member="yami::core::parameters::create_long_long_array" ref="a1fa4ff403b41016d1bf052c917e703cb" args="(const char *name, std::size_t name_length, std::size_t array_length, long long *&amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::create_long_long_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long *&amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new entry of type long long array in the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the new array. </td></tr>
    <tr><td class="paramname">array</td><td>Returned pointer to the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0e1fdf26ff84a35363aaf6b64d324663"></a><!-- doxytag: member="yami::core::parameters::create_long_long_array" ref="a0e1fdf26ff84a35363aaf6b64d324663" args="(const char *name, std::size_t array_length, long long *&amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::create_long_long_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long *&amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new entry of type long long array with null-terminated name and given length. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="aaf5e9bfeb6a4bcea7ec7ab40080f54a1"></a><!-- doxytag: member="yami::core::parameters::get_long_long_array" ref="aaf5e9bfeb6a4bcea7ec7ab40080f54a1" args="(const char *name, std::size_t name_length, long long *&amp;values, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_long_long_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long *&amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the array of long long values from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the internal array buffer to be returned. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the internal array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the given entry does not contain long long array</li>
<li><code>no_such_name</code> if the given name cannot be found</li>
</ul>
</dd></dl>
<p><b>Note:</b> this function gives read-write access to the underlying array, even if it was set as a shallow-copy. </p>

</div>
</div>
<a class="anchor" id="a56e2d46ea21a57f4a6f5cc2fe5ad90b0"></a><!-- doxytag: member="yami::core::parameters::get_long_long_array" ref="a56e2d46ea21a57f4a6f5cc2fe5ad90b0" args="(const char *name, long long *&amp;values, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_long_long_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long *&amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the array of long long values from the entry given by null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a033d5ecc0d16c2bcfff126675bf677a4"></a><!-- doxytag: member="yami::core::parameters::set_double_float_array" ref="a033d5ecc0d16c2bcfff126675bf677a4" args="(const char *name, std::size_t name_length, const double *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_double_float_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type double array to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the array of values to be set. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
</ul>
</dd></dl>
<p><b>Note:</b> The array of values is <em>copied</em> to the internal buffer. </p>

</div>
</div>
<a class="anchor" id="a2f89f8cb5e3981dc271147d7bbb30bd0"></a><!-- doxytag: member="yami::core::parameters::set_double_float_array" ref="a2f89f8cb5e3981dc271147d7bbb30bd0" args="(const char *name, const double *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_double_float_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type double array with null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="ac52b9d03ad90a6387aa0892888cd94b0"></a><!-- doxytag: member="yami::core::parameters::set_double_float_array_shallow" ref="ac52b9d03ad90a6387aa0892888cd94b0" args="(const char *name, std::size_t name_length, const double *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_double_float_array_shallow </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type double array to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the array of values to be set. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
</ul>
</dd></dl>
<p><b>Note:</b> The array of values is <em><b>not</b></em> <em>copied</em> to the internal buffer and the user has to ensure that the given buffer is valid as long as this object refers to it. </p>

</div>
</div>
<a class="anchor" id="a519fb117e3795f57f2552a9b38f2613a"></a><!-- doxytag: member="yami::core::parameters::set_double_float_array_shallow" ref="a519fb117e3795f57f2552a9b38f2613a" args="(const char *name, const double *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_double_float_array_shallow </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts (without copy) a new entry of type double array with null-terminated name and value. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a33d489e753d53ac5bc28a13d767ca009"></a><!-- doxytag: member="yami::core::parameters::create_double_float_array" ref="a33d489e753d53ac5bc28a13d767ca009" args="(const char *name, std::size_t name_length, std::size_t array_length, double *&amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::create_double_float_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new entry of type double float array in the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the new array. </td></tr>
    <tr><td class="paramname">array</td><td>Returned pointer to the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4b7b035ac629bcb555840933ec4042ff"></a><!-- doxytag: member="yami::core::parameters::create_double_float_array" ref="a4b7b035ac629bcb555840933ec4042ff" args="(const char *name, std::size_t array_length, double *&amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::create_double_float_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new entry of type double float array with null-terminated name and given array_length. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="ae3923e37649e834d8344b2152fb364ec"></a><!-- doxytag: member="yami::core::parameters::get_double_float_array" ref="ae3923e37649e834d8344b2152fb364ec" args="(const char *name, std::size_t name_length, double *&amp;values, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_double_float_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the array of double values from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the internal array buffer to be returned. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the internal array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the given entry does not contain double array</li>
<li><code>no_such_name</code> if the given name cannot be found</li>
</ul>
</dd></dl>
<p><b>Note:</b> this function gives read-write access to the underlying array, even if it was set as a shallow-copy. </p>

</div>
</div>
<a class="anchor" id="a2ce30504a370021a5e977b425f65d24f"></a><!-- doxytag: member="yami::core::parameters::get_double_float_array" ref="a2ce30504a370021a5e977b425f65d24f" args="(const char *name, double *&amp;values, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_double_float_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the array of double values from the entry given by null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a7c8413fe178527602b866fded1ea1a2b"></a><!-- doxytag: member="yami::core::parameters::create_string_array" ref="a7c8413fe178527602b866fded1ea1a2b" args="(const char *name, std::size_t name_length, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::create_string_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new empty entry of type string array. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the newly created array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
</ul>
</dd></dl>
<p><b>Note:</b> After creation the array contains empty strings (that is, strings which length is 0). </p>

</div>
</div>
<a class="anchor" id="a83dbc0d4b62ee9a0228e6d878107a816"></a><!-- doxytag: member="yami::core::parameters::create_string_array" ref="a83dbc0d4b62ee9a0228e6d878107a816" args="(const char *name, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::create_string_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new empty entry of type string array with null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="aca27b8950c6ca517757342071761e447"></a><!-- doxytag: member="yami::core::parameters::set_string_in_array" ref="aca27b8950c6ca517757342071761e447" args="(const char *name, std::size_t name_length, std::size_t index, const char *value, std::size_t value_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_string_in_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new string value (possibly replacing the old one) to already existing string array at the given index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">index</td><td>The array index (array slot, starting from 0). </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the value buffer to be set. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">value_length</td><td>Length of the value buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the given entry does not contain string array</li>
<li><code>no_such_index</code> if the given index is out of range</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
<li><code>no_such_name</code> if the given name cannot be found</li>
</ul>
</dd></dl>
<p><b>Note:</b> The value is <em>copied</em> to the internal buffer. </p>

</div>
</div>
<a class="anchor" id="aef0cd412b1851b6f92cdc57964213a61"></a><!-- doxytag: member="yami::core::parameters::set_string_in_array" ref="aef0cd412b1851b6f92cdc57964213a61" args="(const char *name, std::size_t index, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_string_in_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new null-terminated string value to already existing string array (given by null-terminated name) at the given index. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a5001ec4a9ab586b2cb116f5c4f45ab40"></a><!-- doxytag: member="yami::core::parameters::get_string_array_length" ref="a5001ec4a9ab586b2cb116f5c4f45ab40" args="(const char *name, std::size_t name_length, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_string_array_length </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the length of string array that is located at the given entry.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the current entry does not contain string array </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a75ab7f43752f4851196682b1faeee7aa"></a><!-- doxytag: member="yami::core::parameters::get_string_array_length" ref="a75ab7f43752f4851196682b1faeee7aa" args="(const char *name, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_string_array_length </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the length of string array identified by null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="ab58a99b573ebd504c8f32a909adcb3b8"></a><!-- doxytag: member="yami::core::parameters::get_string_in_array" ref="ab58a99b573ebd504c8f32a909adcb3b8" args="(const char *name, std::size_t name_length, std::size_t index, const char *&amp;value, std::size_t &amp;value_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_string_in_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the string value from the given index of string array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">index</td><td>The array index (array slot to be read, starting from 0). </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the internal value buffer to be returned. </td></tr>
    <tr><td class="paramname">value_length</td><td>Length of the internal value buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the given entry does not contain string array</li>
<li><code>no_such_index</code> if the given index is out of range </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="adb32bbb30df0d9a5acf3b9fca453b861"></a><!-- doxytag: member="yami::core::parameters::get_string_in_array" ref="adb32bbb30df0d9a5acf3b9fca453b861" args="(const char *name, std::size_t index, const char *&amp;value, std::size_t &amp;value_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_string_in_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the string value from the given index of string array identified by null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="afc8c15e49031c8a4f7d8e2045f3b5f10"></a><!-- doxytag: member="yami::core::parameters::create_binary_array" ref="afc8c15e49031c8a4f7d8e2045f3b5f10" args="(const char *name, std::size_t name_length, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::create_binary_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new empty entry of type binary array. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the newly created array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
</ul>
</dd></dl>
<p><b>Note:</b> After creation the array contains empty binaries (that is, binaries which length is 0). </p>

</div>
</div>
<a class="anchor" id="a150eb36ba477d31a3758648260ee3f39"></a><!-- doxytag: member="yami::core::parameters::create_binary_array" ref="a150eb36ba477d31a3758648260ee3f39" args="(const char *name, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::create_binary_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new empty entry of type binary array with null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a33b801ce13e69fb4b08aa29e603da8a7"></a><!-- doxytag: member="yami::core::parameters::set_binary_in_array" ref="a33b801ce13e69fb4b08aa29e603da8a7" args="(const char *name, std::size_t name_length, std::size_t index, const void *value, std::size_t value_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_binary_in_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new binary value (possibly replacing the old one) to already existing binary array at the given index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">index</td><td>The array index (array slot, starting from 0). </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the value buffer to be set. </td></tr>
    <tr><td class="paramname">value_length</td><td>Length of the value buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the given entry does not contain binary array</li>
<li><code>no_such_index</code> if the given index is out of range</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
<li><code>no_such_name</code> if the given name cannot be found</li>
</ul>
</dd></dl>
<p><b>Note:</b> The value is <em>copied</em> to the internal buffer. </p>

</div>
</div>
<a class="anchor" id="ade03cf2869b3d34dc1c0ae06ad685aca"></a><!-- doxytag: member="yami::core::parameters::set_binary_in_array" ref="ade03cf2869b3d34dc1c0ae06ad685aca" args="(const char *name, std::size_t index, const void *value, std::size_t value_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::set_binary_in_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new binary value to already existing binary array (given by null-terminated name) at the given index. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="adc0bd21862b51348ea361a7d3a7912fd"></a><!-- doxytag: member="yami::core::parameters::get_binary_array_length" ref="adc0bd21862b51348ea361a7d3a7912fd" args="(const char *name, std::size_t name_length, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_binary_array_length </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the length of binary array that is located at the given entry.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the current entry does not contain binary array </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a2742d6e720689f0cdd15c352d6159c68"></a><!-- doxytag: member="yami::core::parameters::get_binary_array_length" ref="a2742d6e720689f0cdd15c352d6159c68" args="(const char *name, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_binary_array_length </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the length of binary array identified by null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="aca4d63b81afa196b2128901762e54d41"></a><!-- doxytag: member="yami::core::parameters::get_binary_in_array" ref="aca4d63b81afa196b2128901762e54d41" args="(const char *name, std::size_t name_length, std::size_t index, const void *&amp;value, std::size_t &amp;value_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_binary_in_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the binary value from the given index of binary array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">index</td><td>The array index (array slot to be read, starting from 0). </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the internal value buffer to be returned. </td></tr>
    <tr><td class="paramname">value_length</td><td>Length of the internal value buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the given entry does not contain binary array</li>
<li><code>no_such_index</code> if the given index is out of range </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a88bc7ae6c77d4d19d62b0d1bf7928cac"></a><!-- doxytag: member="yami::core::parameters::get_binary_in_array" ref="a88bc7ae6c77d4d19d62b0d1bf7928cac" args="(const char *name, std::size_t index, const void *&amp;value, std::size_t &amp;value_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_binary_in_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the binary value from the given index of binary array identified by null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a57e1e33b2fa00c531ab61bfd18ab9cca"></a><!-- doxytag: member="yami::core::parameters::create_nested_parameters" ref="a57e1e33b2fa00c531ab61bfd18ab9cca" args="(const char *name, std::size_t name_length, parameters *&amp;params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::create_nested_parameters </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> *&amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new nested parameters entry in the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">params</td><td>Pointer to the internally created parameters object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5dc5a2d159295179cae3273e29391e29"></a><!-- doxytag: member="yami::core::parameters::create_nested_parameters" ref="a5dc5a2d159295179cae3273e29391e29" args="(const char *name, parameters *&amp;params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::create_nested_parameters </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> *&amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new nested parameters entry with null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="ae8cdbcee3fce9ded6dd37c058c29b43e"></a><!-- doxytag: member="yami::core::parameters::get_nested_parameters" ref="ae8cdbcee3fce9ded6dd37c058c29b43e" args="(const char *name, std::size_t name_length, parameters *&amp;params) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_nested_parameters </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> *&amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts nested parameters from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">params</td><td>Pointer to the internally stored parameters object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the given entry does not contain nested parameters</li>
<li><code>no_such_name</code> if the given name cannot be found </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a86f0901b6dfec2d54f2569c2bc6e2706"></a><!-- doxytag: member="yami::core::parameters::get_nested_parameters" ref="a86f0901b6dfec2d54f2569c2bc6e2706" args="(const char *name, parameters *&amp;params) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_nested_parameters </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> *&amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts nested parameters from the entry given by its null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a4fbf9d95e811baa47d88f2ed3f806524"></a><!-- doxytag: member="yami::core::parameters::create_nested_array" ref="a4fbf9d95e811baa47d88f2ed3f806524" args="(const char *name, std::size_t name_length, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::create_nested_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new empty entry of type nested parameters array. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the newly created array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
</ul>
</dd></dl>
<p><b>Note:</b> After creation the array contains empty nested objects (that is, parameters objects which do not have any entries). </p>

</div>
</div>
<a class="anchor" id="af165ff9ef48ff57081881dc655df8237"></a><!-- doxytag: member="yami::core::parameters::create_nested_array" ref="af165ff9ef48ff57081881dc655df8237" args="(const char *name, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::create_nested_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new empty entry of type nested parameters array with null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a6adf6d057c46a4ffe919eb621bd8ad1e"></a><!-- doxytag: member="yami::core::parameters::get_nested_array_length" ref="a6adf6d057c46a4ffe919eb621bd8ad1e" args="(const char *name, std::size_t name_length, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_nested_array_length </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the length of nested parameters array that is located at the given entry.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the current entry does not contain nested parameters array </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="afcde131182b7e49fa01c52c063b2f0ed"></a><!-- doxytag: member="yami::core::parameters::get_nested_array_length" ref="afcde131182b7e49fa01c52c063b2f0ed" args="(const char *name, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_nested_array_length </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the length of nested parameters array identified by null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="af6f4fe7a2b23f7c61c27237f22a9d37b"></a><!-- doxytag: member="yami::core::parameters::get_nested_in_array" ref="af6f4fe7a2b23f7c61c27237f22a9d37b" args="(const char *name, std::size_t name_length, std::size_t index, parameters *&amp;nested) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_nested_in_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> *&amp;&#160;</td>
          <td class="paramname"><em>nested</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the nested parameters value from the given index of nested array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">index</td><td>The array index (array slot to be read, starting from 0). </td></tr>
    <tr><td class="paramname">nested</td><td>Pointer to the internally stored parameters object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>bad_type</code> if the given entry does not contain nested parameters array</li>
<li><code>no_such_index</code> if the given index is out of range </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8cd8220ce73281d6c7d36e4a930ac90b"></a><!-- doxytag: member="yami::core::parameters::get_nested_in_array" ref="a8cd8220ce73281d6c7d36e4a930ac90b" args="(const char *name, std::size_t index, parameters *&amp;nested) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_nested_in_array </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> *&amp;&#160;</td>
          <td class="paramname"><em>nested</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the nested parameters value from the given index of nested array identified by null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="abbe7b8d803185b29785c0b455deab01b"></a><!-- doxytag: member="yami::core::parameters::remove" ref="abbe7b8d803185b29785c0b455deab01b" args="(const char *name, std::size_t name_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::remove </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_such_name</code> if the given name cannot be found</li>
</ul>
</dd></dl>
<p><b>Note:</b> The removed entry leaves a <em>hole</em> (empty slot) in the collection that can be reused by newly added entries. </p>

</div>
</div>
<a class="anchor" id="a1ecebb2d4c153937de705342cd43a57e"></a><!-- doxytag: member="yami::core::parameters::remove" ref="a1ecebb2d4c153937de705342cd43a57e" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::remove </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes the entry given by its null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a1b53aa1d01977889db4bff9159f8589a"></a><!-- doxytag: member="yami::core::parameters::size" ref="a1b53aa1d01977889db4bff9159f8589a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t parameters::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the size of the collection - that is, the number of all non-empty slots. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size of the collection </dd></dl>

</div>
</div>
<a class="anchor" id="a5058088c67d4d1a48583f195f8a45079"></a><!-- doxytag: member="yami::core::parameters::get_type" ref="a5058088c67d4d1a48583f195f8a45079" args="(const char *name, std::size_t name_length, parameter_type &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_type </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyami_1_1core.html#ae96e9976f39b4cd83de6301a9581f7b9">parameter_type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the type of the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">t</td><td>The type of the given entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_such_name</code> if the given name cannot be found </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad6c336e24e6d54c9aeb58cd59e81f9f7"></a><!-- doxytag: member="yami::core::parameters::get_type" ref="ad6c336e24e6d54c9aeb58cd59e81f9f7" args="(const char *name, parameter_type &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_type </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyami_1_1core.html#ae96e9976f39b4cd83de6301a9581f7b9">parameter_type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the type of the entry given by its null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a82553546168790a6dd55682a21a4bb64"></a><!-- doxytag: member="yami::core::parameters::get_iterator" ref="a82553546168790a6dd55682a21a4bb64" args="(parameter_iterator &amp;it) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyami_1_1core_1_1parameter__iterator.html">parameter_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the iterator pointing to the beginning of the collection, which means the first used slot. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_entries</code> if this object contains no entries </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a95254a2f00520ae9f145d73fc7e9c6f8"></a><!-- doxytag: member="yami::core::parameters::find" ref="a95254a2f00520ae9f145d73fc7e9c6f8" args="(const char *name, std::size_t name_length, parameter_entry &amp;entry) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>name_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyami_1_1core_1_1parameter__entry.html">parameter_entry</a> &amp;&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the view on the entry specified by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Pointer to the name buffer. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">name_length</td><td>Length of the name buffer. </td></tr>
    <tr><td class="paramname">entry</td><td>The entry view to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_such_name</code> if the given name cannot be found </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0fcde08e589e7029166f1e5f8b7ce256"></a><!-- doxytag: member="yami::core::parameters::find" ref="a0fcde08e589e7029166f1e5f8b7ce256" args="(const char *name, parameter_entry &amp;entry) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyami_1_1core_1_1parameter__entry.html">parameter_entry</a> &amp;&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the on the entry specified by its null-terminated name. See the other overloaded function for details. </p>

</div>
</div>
<a class="anchor" id="a85f5f0cd7903926ecbd34d0d7e8786eb"></a><!-- doxytag: member="yami::core::parameters::merge_from" ref="a85f5f0cd7903926ecbd34d0d7e8786eb" args="(const parameters &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::merge_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Merges the entries from another parameters object. The merged entries can have the same names, in which case the new entries replace existing ones. The merging is deep in the sense that no data is shared between this and other object after the merge - this applies also to those entries that were shallow references in the other object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to be merged into this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a893060f7227a52e9fa9f459b30045773"></a><!-- doxytag: member="yami::core::parameters::clear" ref="a893060f7227a52e9fa9f459b30045773" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears the collection of entries and deallocates dependent structures. After executing the state of this object is as it was immediately after construction. </p>

</div>
</div>
<a class="anchor" id="a4ade3419d33fdabed528ab2dc64d4745"></a><!-- doxytag: member="yami::core::parameters::get_serialize_buffer_size" ref="a4ade3419d33fdabed528ab2dc64d4745" args="(std::size_t &amp;size) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::get_serialize_buffer_size </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the total size of serialization buffer(s) for the current content of this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The computed size of buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>nesting_too_deep</code> if the level of nesting in this object is deeper than the limit </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="classyami_1_1core_1_1serializable.html#acfb6ba8d9b87789a45f4c213de4908c5">yami::core::serializable</a>.</p>

</div>
</div>
<a class="anchor" id="a015d9e9667737105f69733cf5fd21ac8"></a><!-- doxytag: member="yami::core::parameters::serialize" ref="a015d9e9667737105f69733cf5fd21ac8" args="(char **buffers, const std::size_t *buffer_sizes, std::size_t num_of_buffers) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::serialize </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t *&#160;</td>
          <td class="paramname"><em>buffer_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_of_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Serializes the current content of this object into the given buffer(s). The serialization buffer does not have to be contiguous and any number of buffer segments is allowed, provided that the size of each buffer segment is a multiple of 4 (32 bits).<br/>
 The function scatters the serialized data into subsequent buffers as they become filled.<br/>
 The buffers are provided as array of buffer pointers and their sizes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Pointer to the array of buffer pointers (each of type <code>char *</code>). </td></tr>
    <tr><td class="paramname">buffer_sizes</td><td>Pointer to the array of buffer sizes. </td></tr>
    <tr><td class="paramname">num_of_buffers</td><td>Number of buffers described by the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>nesting_too_deep</code> if the level of nesting in this object is deeper than the limit</li>
<li><code>not_enough_space</code> if the buffers are not big enough for all the data </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="classyami_1_1core_1_1serializable.html#a88ac87c424d63cb85ea3de1f46b414d3">yami::core::serializable</a>.</p>

</div>
</div>
<a class="anchor" id="a00c914958c70a6c2b44b9dac3c81eb83"></a><!-- doxytag: member="yami::core::parameters::deserialize" ref="a00c914958c70a6c2b44b9dac3c81eb83" args="(const char **buffers, const std::size_t *buffer_sizes, std::size_t num_of_buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> parameters::deserialize </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t *&#160;</td>
          <td class="paramname"><em>buffer_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_of_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deserializes content from the given buffer(s). The data buffer does not have to be contiguous and any number of buffer segments is allowed, provided that the size of each buffer segment is a multiple of 4 (32 bits).<br/>
 The function gathers the serialized data from subsequent buffers as they are consumed.<br/>
 The buffers are provided as array of buffer pointers and their sizes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Pointer to the array of buffer pointers (each of type <code>const char *</code>). </td></tr>
    <tr><td class="paramname">buffer_sizes</td><td>Pointer to the array of buffer sizes. </td></tr>
    <tr><td class="paramname">num_of_buffers</td><td>Number of buffers described by the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>nesting_too_deep</code> if the level of nesting in the data stream is deeper than the limit</li>
<li><code>not_enough_space</code> if the buffers do not contain all expected data</li>
<li><code>unexpected_value</code> if the data stream contains a value that cannot be properly interpreted</li>
</ul>
</dd></dl>
<p><b>Note:</b> The current content of this object is not cleared before attempting deserialization and each retrieved data element is <em>merged</em> into the current content as if done by individual calls to appropriate <code>set_XYZ</code> functions.<br/>
 In most cases deserialization will be performed to the empty parameters object (to reconstruct it to the form that was used for serialization), but deserialization onto non-empty object might be occasionally useful as a way of merging two collections. </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceyami.html">yami</a>      </li>
      <li class="navelem"><a class="el" href="namespaceyami_1_1core.html">core</a>      </li>
      <li class="navelem"><a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a>      </li>

    <li class="footer">Generated on Tue Aug 6 2013 22:41:04 for YAMI4 - core by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
