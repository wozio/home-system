<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>YAMI4 - core: yami::core::agent Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">YAMI4 - core
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classyami_1_1core_1_1agent.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">yami::core::agent Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="yami::core::agent" -->
<p>Message broker.  
 <a href="classyami_1_1core_1_1agent.html#details">More...</a></p>

<p><code>#include &lt;agent.h&gt;</code></p>

<p><a href="classyami_1_1core_1_1agent-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#af5eb66189d689e9d7b5642ebda2c8fbc">agent</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#af5eb66189d689e9d7b5642ebda2c8fbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#acb8a643b3e4b55639ba30ea51fbade2c">init</a> (<a class="el" href="namespaceyami_1_1core.html#aaa816df903d9401a16892a1d062f2cf6">incoming_message_dispatch_function</a> dispatch_callback, void *dispatch_hint, <a class="el" href="namespaceyami_1_1core.html#a56f5495ac8616a2d9ba211fb8bff04c8">closed_connection_function</a> disconnection_hook=NULL, void *disconnection_hook_hint=NULL, void *working_area=NULL, std::size_t area_size=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization.  <a href="#acb8a643b3e4b55639ba30ea51fbade2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#a7cfbedb87d7ea7f59304e757a6673804">init</a> (const <a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> &amp;configuration_options, <a class="el" href="namespaceyami_1_1core.html#aaa816df903d9401a16892a1d062f2cf6">incoming_message_dispatch_function</a> dispatch_callback, void *dispatch_hint, <a class="el" href="namespaceyami_1_1core.html#a56f5495ac8616a2d9ba211fb8bff04c8">closed_connection_function</a> disconnection_hook=NULL, void *disconnection_hook_hint=NULL, void *working_area=NULL, std::size_t area_size=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization.  <a href="#a7cfbedb87d7ea7f59304e757a6673804"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#aab4eb564141be8560b0aa5328c5c74fe">install_event_notifications</a> (<a class="el" href="namespaceyami_1_1core.html#a59ee8aaa4d93575075a2c19fad5c7cb0">event_notification_function</a> event_notification_callback, void *event_notification_hint)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Installation of logging notifications callback.  <a href="#aab4eb564141be8560b0aa5328c5c74fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#a4c6f8803eae981e687b86ddd364a4957">install_io_error_logger</a> (<a class="el" href="namespaceyami_1_1core.html#a8a6b5e42158680ed6f5aa369326ec5c6">io_error_function</a> io_error_callback, void *io_error_callback_hint)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Installation of I/O error logging callback.  <a href="#a4c6f8803eae981e687b86ddd364a4957"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#ae2c40409af17945643fdbd4bc4fad7d6">clean</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup.  <a href="#ae2c40409af17945643fdbd4bc4fad7d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#a73d9031631414177ec4d75d05f1efb4c">~agent</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a73d9031631414177ec4d75d05f1efb4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#abc75c0e815a9e8a8a5dbba41e16a8adf">open</a> (const char *target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new channel for the given target.  <a href="#abc75c0e815a9e8a8a5dbba41e16a8adf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#aa5dcf6ad67009f0882a454fce41a9edd">open</a> (const char *target, <a class="el" href="classyami_1_1core_1_1channel__descriptor.html">channel_descriptor</a> &amp;cd, bool &amp;created_new_channel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new channel for the given target.  <a href="#aa5dcf6ad67009f0882a454fce41a9edd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#af14346a449e18a3bfcd773fd21313f2a">open</a> (const char *target, <a class="el" href="classyami_1_1core_1_1channel__descriptor.html">channel_descriptor</a> &amp;cd, bool &amp;created_new_channel, const <a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> *overriding_options)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new channel for the given target with a set of overriding options.  <a href="#af14346a449e18a3bfcd773fd21313f2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#a851c5c2f8f708fe377b02142efe3652f">is_open</a> (const char *target, <a class="el" href="classyami_1_1core_1_1channel__descriptor.html">channel_descriptor</a> &amp;existing_channel) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given channel is already open.  <a href="#a851c5c2f8f708fe377b02142efe3652f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#a71386274ddd96181a77f1eef2119bd67">close</a> (<a class="el" href="classyami_1_1core_1_1channel__descriptor.html">channel_descriptor</a> cd, std::size_t priority=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the given channel.  <a href="#a71386274ddd96181a77f1eef2119bd67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#a761f27a98eb6f7f3872c4a4992fdc32b">close</a> (const char *target, std::size_t priority=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the given channel.  <a href="#a761f27a98eb6f7f3872c4a4992fdc32b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#a1d0755564749cb31f65c7d17c1ce46fb">post</a> (<a class="el" href="classyami_1_1core_1_1channel__descriptor.html">channel_descriptor</a> cd, const <a class="el" href="classyami_1_1core_1_1serializable.html">serializable</a> &amp;message_header, const <a class="el" href="classyami_1_1core_1_1serializable.html">serializable</a> &amp;message_body, std::size_t priority=0, <a class="el" href="namespaceyami_1_1core.html#a1aa2a43c76338a2d7b43487225fd7d3a">message_progress_function</a> progress_callback=NULL, void *progress_hint=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts new message for sending.  <a href="#a1d0755564749cb31f65c7d17c1ce46fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#a4b9ae98e8d1578adf41b22fa136a54df">post</a> (const char *target, const <a class="el" href="classyami_1_1core_1_1serializable.html">serializable</a> &amp;message_header, const <a class="el" href="classyami_1_1core_1_1serializable.html">serializable</a> &amp;message_body, std::size_t priority=0, <a class="el" href="namespaceyami_1_1core.html#a1aa2a43c76338a2d7b43487225fd7d3a">message_progress_function</a> progress_callback=NULL, void *progress_hint=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts new message for sending.  <a href="#a4b9ae98e8d1578adf41b22fa136a54df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#a6e49189ea425e290249358988bab6887">add_listener</a> (const char *target, <a class="el" href="namespaceyami_1_1core.html#abe7fc7b4eaebfcd45ae759aaa2236429">new_incoming_connection_function</a> connection_hook=NULL, void *connection_hook_hint=NULL, const char **resolved_target=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new listener.  <a href="#a6e49189ea425e290249358988bab6887"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#a8b61d4a4b65458e6b49d2977074824c8">remove_listener</a> (const char *target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes existing listener.  <a href="#a8b61d4a4b65458e6b49d2977074824c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#a3ac78df911dbcdb2b8bc8d1d15622211">do_some_work</a> (std::size_t timeout, bool allow_outgoing_traffic=true, bool allow_incoming_traffic=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a portion of I/O or internal management work.  <a href="#a3ac78df911dbcdb2b8bc8d1d15622211"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9642492b93afe84291486e9353e83081"></a><!-- doxytag: member="yami::core::agent::interrupt_work_waiter" ref="a9642492b93afe84291486e9353e83081" args="()" -->
<a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#a9642492b93afe84291486e9353e83081">interrupt_work_waiter</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Artificially interrupts the wait state of do_some_work. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4e84cd9c30d75a7ddc44bef2068dfb4"></a><!-- doxytag: member="yami::core::agent::get_channel_usage" ref="af4e84cd9c30d75a7ddc44bef2068dfb4" args="(int &amp;max_allowed, int &amp;used)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1core_1_1agent.html#af4e84cd9c30d75a7ddc44bef2068dfb4">get_channel_usage</a> (int &amp;max_allowed, int &amp;used)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the selector's channel usage counters. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The message broker that encapsulates physical channel management, incoming and outgoing message queues, listeners and resource management.</p>
<p>A single agent object can manage many listeners, which are responsible for accepting remote connections, and many incoming and outgoing connections.</p>
<p>The agent objects can be created and destroyed without constraints on the stack, on the free store or as static objects. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af5eb66189d689e9d7b5642ebda2c8fbc"></a><!-- doxytag: member="yami::core::agent::agent" ref="af5eb66189d689e9d7b5642ebda2c8fbc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">agent::agent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates an uninitialized agent object.</p>
<p>The only valid operations that can be executed after constructing a new agent object are:</p>
<ul>
<li><code>init</code> - to initialize it to the operational state</li>
<li><code>clean</code> - which is an empty operation in this case</li>
<li>destruction </li>
</ul>

</div>
</div>
<a class="anchor" id="a73d9031631414177ec4d75d05f1efb4c"></a><!-- doxytag: member="yami::core::agent::~agent" ref="a73d9031631414177ec4d75d05f1efb4c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">agent::~agent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls <code>clean</code>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acb8a643b3e4b55639ba30ea51fbade2c"></a><!-- doxytag: member="yami::core::agent::init" ref="acb8a643b3e4b55639ba30ea51fbade2c" args="(incoming_message_dispatch_function dispatch_callback, void *dispatch_hint, closed_connection_function disconnection_hook=NULL, void *disconnection_hook_hint=NULL, void *working_area=NULL, std::size_t area_size=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> agent::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyami_1_1core.html#aaa816df903d9401a16892a1d062f2cf6">incoming_message_dispatch_function</a>&#160;</td>
          <td class="paramname"><em>dispatch_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dispatch_hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyami_1_1core.html#a56f5495ac8616a2d9ba211fb8bff04c8">closed_connection_function</a>&#160;</td>
          <td class="paramname"><em>disconnection_hook</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>disconnection_hook_hint</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>working_area</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>area_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes the agent object to the operational state with default values for runtime options. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatch_callback</td><td>Pointer to the user-defined function that will be called when the new incoming message is completed. This callback can be NULL. </td></tr>
    <tr><td class="paramname">dispatch_hint</td><td>Any parameter that will be passed to the <code>dispatch_callback</code> function. </td></tr>
    <tr><td class="paramname">disconnection_hook</td><td>Pointer to the user-defined function that will be called when the existing connection is closed. The closing connection can be either the one that was explicitly created or the one that was automatically added by one of the listeners. In either case, the reason for closing the connection is passed to the callback as well. This callback can be NULL. </td></tr>
    <tr><td class="paramname">disconnection_hook_hint</td><td>Any parameter that will be passed to the <code>disconnection_hook</code> function. </td></tr>
    <tr><td class="paramname">working_area</td><td>If not NULL, forces this object to use the given area for all private storage. </td></tr>
    <tr><td class="paramname">area_size</td><td>If different than 0, indicates the size of the private memory area that will be used for all dependent structures. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if the operation was successful or the appropriate problem description</li>
</ul>
</dd></dl>
<p><b>Notes:</b></p>
<ul>
<li>If <code>working_area == NULL &amp;&amp; area_size == 0</code> (the default) then all dependent objects are separately allocated on the global store.</li>
<li>If <code>working_area != NULL &amp;&amp; area_size != 0</code> then the given block is used as a private area.</li>
</ul>
<p><b>Note:</b> Do not attempt to create objects sharing the same working area. </p>

</div>
</div>
<a class="anchor" id="a7cfbedb87d7ea7f59304e757a6673804"></a><!-- doxytag: member="yami::core::agent::init" ref="a7cfbedb87d7ea7f59304e757a6673804" args="(const parameters &amp;configuration_options, incoming_message_dispatch_function dispatch_callback, void *dispatch_hint, closed_connection_function disconnection_hook=NULL, void *disconnection_hook_hint=NULL, void *working_area=NULL, std::size_t area_size=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> agent::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>configuration_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyami_1_1core.html#aaa816df903d9401a16892a1d062f2cf6">incoming_message_dispatch_function</a>&#160;</td>
          <td class="paramname"><em>dispatch_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dispatch_hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyami_1_1core.html#a56f5495ac8616a2d9ba211fb8bff04c8">closed_connection_function</a>&#160;</td>
          <td class="paramname"><em>disconnection_hook</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>disconnection_hook_hint</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>working_area</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>area_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes the agent object to the operational state with runtime options that can override default settings.</p>
<p>See the other <code>init</code> function for the description of paramters. </p>

</div>
</div>
<a class="anchor" id="aab4eb564141be8560b0aa5328c5c74fe"></a><!-- doxytag: member="yami::core::agent::install_event_notifications" ref="aab4eb564141be8560b0aa5328c5c74fe" args="(event_notification_function event_notification_callback, void *event_notification_hint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void agent::install_event_notifications </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyami_1_1core.html#a59ee8aaa4d93575075a2c19fad5c7cb0">event_notification_function</a>&#160;</td>
          <td class="paramname"><em>event_notification_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>event_notification_hint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Installs the logging monitor with the given hint. The previously installed callback (if any) is overriden.</p>
<p><b>Note:</b> This function should be called after init. This function is not synchronized. </p>

</div>
</div>
<a class="anchor" id="a4c6f8803eae981e687b86ddd364a4957"></a><!-- doxytag: member="yami::core::agent::install_io_error_logger" ref="a4c6f8803eae981e687b86ddd364a4957" args="(io_error_function io_error_callback, void *io_error_callback_hint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void agent::install_io_error_logger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyami_1_1core.html#a8a6b5e42158680ed6f5aa369326ec5c6">io_error_function</a>&#160;</td>
          <td class="paramname"><em>io_error_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>io_error_callback_hint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Installs the I/O error logging callback with the given hint. The previously installed callback (if any) is overriden.</p>
<p><b>Note:</b> This function should be called after init. This function is not synchronized. </p>

</div>
</div>
<a class="anchor" id="ae2c40409af17945643fdbd4bc4fad7d6"></a><!-- doxytag: member="yami::core::agent::clean" ref="ae2c40409af17945643fdbd4bc4fad7d6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void agent::clean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cleans up the dependent structures and closes all physical connections and listeners. After calling this function the agent object is back in the uninitialized state and can be reused by initializing it again.</p>
<p>The memory structures are cleaned up (deallocated) <em>only</em> if each of them was separately allocated on the global store. If the internal structures were created with externally provided working area (that is, when <code>working_area != NULL</code> when the agent was initialized) then no memory cleanup is performed. </p>

</div>
</div>
<a class="anchor" id="abc75c0e815a9e8a8a5dbba41e16a8adf"></a><!-- doxytag: member="yami::core::agent::open" ref="abc75c0e815a9e8a8a5dbba41e16a8adf" args="(const char *target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> agent::open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new channel for the given target. If the channel already exists for the given target, this function does nothing.</p>
<p>The supported target formats are:</p>
<ul>
<li>"tcp://host:port" for TCP/IP connections, where <code>host</code> can be provided in the symbolic or numeric form</li>
<li>"udp://host:port" for UDP communication, where <code>host</code> can be provided in the symbolic or numeric form</li>
<li>"unix://path" for Unix connections, where <code>path</code> can be relative or absolute</li>
<li>"file://filename" or "file://filename?write" for writing to regular files</li>
<li>"file://filename?read" for reading from regular files</li>
<li>"file://filename?append" for appending to regular files</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target for the new connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if the operation was successful or the appropriate problem description </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa5dcf6ad67009f0882a454fce41a9edd"></a><!-- doxytag: member="yami::core::agent::open" ref="aa5dcf6ad67009f0882a454fce41a9edd" args="(const char *target, channel_descriptor &amp;cd, bool &amp;created_new_channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> agent::open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyami_1_1core_1_1channel__descriptor.html">channel_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>created_new_channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new channel for the given target or find the existing channel with the same target.</p>
<p>See the other <code>open</code> function for the description of valid target formats.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target for the new connection. </td></tr>
    <tr><td class="paramname">cd</td><td>The descriptor that is filled so that it refers to the newly created or found channel. </td></tr>
    <tr><td class="paramname">created_new_channel</td><td>set to true if a new channel was created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if the operation was successful or the appropriate problem description </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af14346a449e18a3bfcd773fd21313f2a"></a><!-- doxytag: member="yami::core::agent::open" ref="af14346a449e18a3bfcd773fd21313f2a" args="(const char *target, channel_descriptor &amp;cd, bool &amp;created_new_channel, const parameters *overriding_options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> agent::open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyami_1_1core_1_1channel__descriptor.html">channel_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>created_new_channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyami_1_1core_1_1parameters.html">parameters</a> *&#160;</td>
          <td class="paramname"><em>overriding_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the new channel is created, it will use the overriding options instead of the ones used by the agent. See the other overload for description. </p>

</div>
</div>
<a class="anchor" id="a851c5c2f8f708fe377b02142efe3652f"></a><!-- doxytag: member="yami::core::agent::is_open" ref="a851c5c2f8f708fe377b02142efe3652f" args="(const char *target, channel_descriptor &amp;existing_channel) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> agent::is_open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyami_1_1core_1_1channel__descriptor.html">channel_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>existing_channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks if the given channel is already open.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target name to check. </td></tr>
    <tr><td class="paramname">existing_channel</td><td>The descriptor that is filled so that it refers to the found channel, if it exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if the channel is already open</li>
<li><code>no_such_name</code> if the channel is not open </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a71386274ddd96181a77f1eef2119bd67"></a><!-- doxytag: member="yami::core::agent::close" ref="a71386274ddd96181a77f1eef2119bd67" args="(channel_descriptor cd, std::size_t priority=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> agent::close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyami_1_1core_1_1channel__descriptor.html">channel_descriptor</a>&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Closes the channel identified by the given descriptor.</p>
<p>The priority allows to properly handle the existing outgoing messages that are waiting in the outgoing queue for transmission. The existing messages with lower priority are abandoned, whereas the existing messages with priority equal or higher to the one provided as parameter are retained in the outgoing queue and are properly pushed for transmission before the channel is physically closed. The channel is closed immediately only if there are no messages waiting in its outgoing queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cd</td><td>Descriptor of the channel that should be closed. </td></tr>
    <tr><td class="paramname">priority</td><td>Priority of the request, respects existing messages in the outgoing queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if the operation was successful or the appropriate problem description </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a761f27a98eb6f7f3872c4a4992fdc32b"></a><!-- doxytag: member="yami::core::agent::close" ref="a761f27a98eb6f7f3872c4a4992fdc32b" args="(const char *target, std::size_t priority=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> agent::close </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Closes the channel identified by the target name.</p>
<p>See the other <code>close</code> function for the description of arguments, return values and the discussion of priorities. </p>

</div>
</div>
<a class="anchor" id="a1d0755564749cb31f65c7d17c1ce46fb"></a><!-- doxytag: member="yami::core::agent::post" ref="a1d0755564749cb31f65c7d17c1ce46fb" args="(channel_descriptor cd, const serializable &amp;message_header, const serializable &amp;message_body, std::size_t priority=0, message_progress_function progress_callback=NULL, void *progress_hint=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> agent::post </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyami_1_1core_1_1channel__descriptor.html">channel_descriptor</a>&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyami_1_1core_1_1serializable.html">serializable</a> &amp;&#160;</td>
          <td class="paramname"><em>message_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyami_1_1core_1_1serializable.html">serializable</a> &amp;&#160;</td>
          <td class="paramname"><em>message_body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyami_1_1core.html#a1aa2a43c76338a2d7b43487225fd7d3a">message_progress_function</a>&#160;</td>
          <td class="paramname"><em>progress_callback</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>progress_hint</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Posts a new message to the outgoing queue of the given channel.</p>
<p>The message is composed of two sets of parameters, one for the header information and one for the body. This distinction is supposed to support arbitrary routing conventions defined by user code. Any of these parts can be empty.</p>
<p>The priority of the message is taken into account for proper ordering of the frames in the outgoing queue - frames created for messages with higher priority will be transmitted before frames having lower priority. Messages with equal priority are ordered according to the FIFO regime.</p>
<p>The callback function can be provided to allow the user code trace the progress of the message. For each frame that was successfully pushed for physical transmission the callback is performed with the number of bytes that were transmitted from the beginning of the message and the total number of bytes for the whole message. When these two arguments are equal then it indicates that the whole message has been transmitted. If both are zero it means that there was an error and the message was abandoned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cd</td><td>Descriptor of the channel that should be used for sending. </td></tr>
    <tr><td class="paramname">message_header</td><td>The parameters object containing (arbitrary) header information - this object can be empty. </td></tr>
    <tr><td class="paramname">message_body</td><td>The parameters object containing (arbitrary) body information - this object can be empty. </td></tr>
    <tr><td class="paramname">priority</td><td>Priority of the request, respects existing frames in the outgoing queue. </td></tr>
    <tr><td class="paramname">progress_callback</td><td>Pointer to the user-defined function that will be called for tracking transmission progress. This callback can be NULL. </td></tr>
    <tr><td class="paramname">progress_hint</td><td>Any parameter that will be passed to the <code>progress_callback</code> function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b9ae98e8d1578adf41b22fa136a54df"></a><!-- doxytag: member="yami::core::agent::post" ref="a4b9ae98e8d1578adf41b22fa136a54df" args="(const char *target, const serializable &amp;message_header, const serializable &amp;message_body, std::size_t priority=0, message_progress_function progress_callback=NULL, void *progress_hint=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> agent::post </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyami_1_1core_1_1serializable.html">serializable</a> &amp;&#160;</td>
          <td class="paramname"><em>message_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyami_1_1core_1_1serializable.html">serializable</a> &amp;&#160;</td>
          <td class="paramname"><em>message_body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyami_1_1core.html#a1aa2a43c76338a2d7b43487225fd7d3a">message_progress_function</a>&#160;</td>
          <td class="paramname"><em>progress_callback</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>progress_hint</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Posts a new message to the outgoing queue of the given channel where the channel is identified by its target.</p>
<p>See the other <code>post</code> function for the description of arguments and their semantics. </p>

</div>
</div>
<a class="anchor" id="a6e49189ea425e290249358988bab6887"></a><!-- doxytag: member="yami::core::agent::add_listener" ref="a6e49189ea425e290249358988bab6887" args="(const char *target, new_incoming_connection_function connection_hook=NULL, void *connection_hook_hint=NULL, const char **resolved_target=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> agent::add_listener </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyami_1_1core.html#abe7fc7b4eaebfcd45ae759aaa2236429">new_incoming_connection_function</a>&#160;</td>
          <td class="paramname"><em>connection_hook</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>connection_hook_hint</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>resolved_target</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a new listener for the given target address.</p>
<p>The supported target formats are:</p>
<ul>
<li>"tcp://host:port" for TCP/IP connections, where <code>host</code> can be provided in the symbolic or numeric form</li>
<li>"tcp://*:port" for TCP/IP connections, for "any" local address</li>
<li>"tcp://port" for TCP/IP connections, for "any" local address</li>
<li>"udp://host:port" for UDP communication, with rules as for TCP/IP</li>
<li>"unix://path" for Unix connections</li>
</ul>
<p>The port for TCP/IP and UDP protocols can be <code>0</code> or <code>*</code>, in which case the actual port number is assigned by the system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target for the new listener. </td></tr>
    <tr><td class="paramname">connection_hook</td><td>Pointer to the user-defined function that will be called when there is a new incoming connection accepted by this listener. This function can intercept and reject the incoming connection. This callback can be NULL. </td></tr>
    <tr><td class="paramname">connection_hook_hint</td><td>Any parameter that will be passed to the <code>connection_hook</code> function. </td></tr>
    <tr><td class="paramname">resolved_target</td><td>The pointer to actual (resolved) target after the given target is bound. If NULL, the resolved target is not propagated back to caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if the operation was successful or the appropriate problem description</li>
</ul>
</dd></dl>
<p><b>Note</b>: The agent does not check whether the given target is already used and if there is a conflict it can be reported as an I/O error, depending on the listener protocol. </p>

</div>
</div>
<a class="anchor" id="a8b61d4a4b65458e6b49d2977074824c8"></a><!-- doxytag: member="yami::core::agent::remove_listener" ref="a8b61d4a4b65458e6b49d2977074824c8" args="(const char *target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> agent::remove_listener </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes the listener denoted by its actual target name. Note that the actual target name might be different from the name provided when the listener was created, due to target resolution. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Target identifying the listener to remove. If the listener is not found, this function does nothing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if the operation was successful or the appropriate problem description </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a3ac78df911dbcdb2b8bc8d1d15622211"></a><!-- doxytag: member="yami::core::agent::do_some_work" ref="a3ac78df911dbcdb2b8bc8d1d15622211" args="(std::size_t timeout, bool allow_outgoing_traffic=true, bool allow_incoming_traffic=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami_1_1core.html#a1591f8788ea25236932d97fecee50cc1">result</a> agent::do_some_work </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_outgoing_traffic</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_incoming_traffic</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Performs a portion of work with the given timeout. If there is some pending work at the call time it is performed immediately and function returns without waiting for further work; otherwise the call blocks waiting for the work with the given timeout.</p>
<p>The pending work can include any of:</p>
<ul>
<li>any of the listeners is ready to accept new connection</li>
<li>any of the channels is ready for reading data</li>
<li>any of the channels is ready for output operation and there are pending frames in its outgoing queue</li>
<li>there was some change in the internal data structures that needs to be acted upon</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds. </td></tr>
    <tr><td class="paramname">allow_outgoing_traffic</td><td>Flow control flag. </td></tr>
    <tr><td class="paramname">allow_incoming_traffic</td><td>Flow control flag.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note</b>: All callbacks initiated by the agent are executed in the context of the thread that calls this function. The thread calling this function is also the only one that performs actual data transfer.</p>
<p><b>Note</b>: The timeout value is subject to system limits as defined for the select function.</p>
<p><b>Note</b>: In the typical usage scenario this function should be called in a tight loop. </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceyami.html">yami</a>      </li>
      <li class="navelem"><a class="el" href="namespaceyami_1_1core.html">core</a>      </li>
      <li class="navelem"><a class="el" href="classyami_1_1core_1_1agent.html">agent</a>      </li>

    <li class="footer">Generated on Tue Aug 6 2013 22:41:03 for YAMI4 - core by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
