<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>YAMI4 - C++ general-purpose interface: yami::agent Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">YAMI4 - C++ general-purpose interface
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classyami_1_1agent.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">yami::agent Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="yami::agent" -->
<p>Message broker.  
 <a href="classyami_1_1agent.html#details">More...</a></p>

<p><code>#include &lt;agent.h&gt;</code></p>

<p><a href="classyami_1_1agent-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66a2581eed6c243400a1a4ea1d980a8d"></a><!-- doxytag: member="yami::agent::outgoing_message_id" ref="a66a2581eed6c243400a1a4ea1d980a8d" args="" -->
typedef long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#a66a2581eed6c243400a1a4ea1d980a8d">outgoing_message_id</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Outgoing message identifier type. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#aed8555db64017b0f3b6fb11781c59a40">agent</a> (const <a class="el" href="classyami_1_1parameters.html">parameters</a> &amp;options=<a class="el" href="classyami_1_1parameters.html">parameters</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#aed8555db64017b0f3b6fb11781c59a40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#af4d51ccd632e77d194da5faed3871ad1">agent</a> (<a class="el" href="classyami_1_1event__callback.html">event_callback</a> &amp;event_listener, const <a class="el" href="classyami_1_1parameters.html">parameters</a> &amp;options=<a class="el" href="classyami_1_1parameters.html">parameters</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#af4d51ccd632e77d194da5faed3871ad1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#a73d9031631414177ec4d75d05f1efb4c">~agent</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a73d9031631414177ec4d75d05f1efb4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#ad4d352e95c7c0207a85e51b6e0e8f7c2">add_listener</a> (const std::string &amp;listener)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new listener.  <a href="#ad4d352e95c7c0207a85e51b6e0e8f7c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#a99a757fca59ded7fad7021804a5f74aa">remove_listener</a> (const std::string &amp;listener)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes existing listener.  <a href="#a99a757fca59ded7fad7021804a5f74aa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#a031b46c55b480ebb62eaba0ee521aaba">register_object</a> (const std::string &amp;object_name, functor &amp;f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the new logical destination object.  <a href="#a031b46c55b480ebb62eaba0ee521aaba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#a4e2db2c61d13c7ba9db6bd0078b49c8e">register_value_publisher</a> (const std::string &amp;object_name, <a class="el" href="classyami_1_1value__publisher.html">value_publisher</a> &amp;publisher)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the value publisher as a new logical object.  <a href="#a4e2db2c61d13c7ba9db6bd0078b49c8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#ad43d2ef6c6977d053369bb2ed8d5610e">unregister_object</a> (const std::string &amp;object_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters the logical destination object.  <a href="#ad43d2ef6c6977d053369bb2ed8d5610e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#adb8ff8baef4521d7c694a09f9e7a844a">open_connection</a> (const std::string &amp;target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the new connection.  <a href="#adb8ff8baef4521d7c694a09f9e7a844a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#a5cf1f567dcc83fe784387b849d7003ad">open_connection</a> (const std::string &amp;target, const <a class="el" href="classyami_1_1parameters.html">parameters</a> &amp;options)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the new connection with overriding options.  <a href="#a5cf1f567dcc83fe784387b849d7003ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::auto_ptr&lt; <a class="el" href="classyami_1_1outgoing__message.html">outgoing_message</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#a03dd5bb46dff202f7cf81e8fc6760366">send</a> (const std::string &amp;target, const std::string &amp;object_name, const std::string &amp;message_name, const <a class="el" href="classyami_1_1serializable.html">serializable</a> &amp;content=<a class="el" href="classyami_1_1parameters.html">parameters</a>(), std::size_t priority=0, bool auto_connect=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the new outgoing message.  <a href="#a03dd5bb46dff202f7cf81e8fc6760366"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#a4645cf70fa85ead4f35f5619033918ed">send</a> (<a class="el" href="classyami_1_1outgoing__message.html">outgoing_message</a> &amp;message, const std::string &amp;target, const std::string &amp;object_name, const std::string &amp;message_name, const <a class="el" href="classyami_1_1serializable.html">serializable</a> &amp;content=<a class="el" href="classyami_1_1parameters.html">parameters</a>(), std::size_t priority=0, bool auto_connect=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the outgoing message.  <a href="#a4645cf70fa85ead4f35f5619033918ed"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classyami_1_1agent.html#a66a2581eed6c243400a1a4ea1d980a8d">outgoing_message_id</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#ac158f696cb51075812aeb0bbdbcc9594">send</a> (functor &amp;f, const std::string &amp;target, const std::string &amp;object_name, const std::string &amp;message_name, const <a class="el" href="classyami_1_1serializable.html">serializable</a> &amp;content=<a class="el" href="classyami_1_1parameters.html">parameters</a>(), std::size_t priority=0, bool auto_connect=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the outgoing message.  <a href="#ac158f696cb51075812aeb0bbdbcc9594"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#a31b1b95bb891759b7048bb1c04a9da37">clean_outgoing_message_callback</a> (<a class="el" href="classyami_1_1agent.html#a66a2581eed6c243400a1a4ea1d980a8d">outgoing_message_id</a> id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans internal resources for the given message callback.  <a href="#a31b1b95bb891759b7048bb1c04a9da37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#a6ec63dc6cde0b6c996e5568a043c11df">send_one_way</a> (const std::string &amp;target, const std::string &amp;object_name, const std::string &amp;message_name, const <a class="el" href="classyami_1_1serializable.html">serializable</a> &amp;content=<a class="el" href="classyami_1_1parameters.html">parameters</a>(), std::size_t priority=0, bool auto_connect=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the new outgoing message.  <a href="#a6ec63dc6cde0b6c996e5568a043c11df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#a9ae953bcda452d0ed423eceadae711f9">close_connection</a> (const std::string &amp;target, std::size_t priority=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the given communication channel.  <a href="#a9ae953bcda452d0ed423eceadae711f9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#a1ba71027935ac808853ff801ebe45551">register_connection_event_monitor</a> (functor &amp;f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the monitor for connection-related events.  <a href="#a1ba71027935ac808853ff801ebe45551"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#a2768b563f95f90aab00e59b1c9d1a029">register_io_error_logger</a> (functor &amp;f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the logger for I/O errors.  <a href="#a2768b563f95f90aab00e59b1c9d1a029"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#ab1073b18617073dc36e991b03fd20ada">get_outgoing_flow_state</a> (std::size_t &amp;current_level, std::size_t &amp;high_water_mark, std::size_t &amp;low_water_mark) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the state of overall outgoing flow.  <a href="#ab1073b18617073dc36e991b03fd20ada"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1agent.html#af4e84cd9c30d75a7ddc44bef2068dfb4">get_channel_usage</a> (int &amp;max_allowed, int &amp;used)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the selector's channel usage counters.  <a href="#af4e84cd9c30d75a7ddc44bef2068dfb4"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The message broker that encapsulates physical channel management, incoming and outgoing message queues, listeners and resource management.</p>
<p>A single agent object can manage many listeners, which are responsible for accepting remote connections, and many incoming and outgoing connections.</p>
<p>The agent objects can be created and destroyed without constraints on the stack, on the free store or as static objects.</p>
<p>The objects of this class can be safely used by multiple threads. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aed8555db64017b0f3b6fb11781c59a40"></a><!-- doxytag: member="yami::agent::agent" ref="aed8555db64017b0f3b6fb11781c59a40" args="(const parameters &amp;options=parameters())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">agent::agent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyami_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="classyami_1_1parameters.html">parameters</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates the message broker and starts its internal threads. The broker created with this constructor has no listener. </p>

</div>
</div>
<a class="anchor" id="af4d51ccd632e77d194da5faed3871ad1"></a><!-- doxytag: member="yami::agent::agent" ref="af4d51ccd632e77d194da5faed3871ad1" args="(event_callback &amp;event_listener, const parameters &amp;options=parameters())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">agent::agent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyami_1_1event__callback.html">event_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>event_listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyami_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="classyami_1_1parameters.html">parameters</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates the message broker with event notification callback. The broker created with this constructor has no listener. </p>

</div>
</div>
<a class="anchor" id="a73d9031631414177ec4d75d05f1efb4c"></a><!-- doxytag: member="yami::agent::~agent" ref="a73d9031631414177ec4d75d05f1efb4c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">agent::~agent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The destructor stops the internal threads and cleans up all internal data structures.</p>
<p><b>Note:</b> The messages and replies that were posted for transmission and that have not yet been fully transmitted are abandoned; in the case of outgoing messages their state is properly notified about that fact. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad4d352e95c7c0207a85e51b6e0e8f7c2"></a><!-- doxytag: member="yami::agent::add_listener" ref="ad4d352e95c7c0207a85e51b6e0e8f7c2" args="(const std::string &amp;listener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string agent::add_listener </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a new listener for the given target address.</p>
<p>The supported target formats are:</p>
<ul>
<li>"tcp://host:port" for TCP/IP connections, where <code>host</code> can be provided in the symbolic or numeric form</li>
<li>"tcp://*:port" for TCP/IP connections, for "any" local address</li>
<li>"tcp://port" for TCP/IP connections, for "any" local address</li>
<li>"udp://host:port" for UDP communication, with rules as for TCP/IP</li>
<li>"unix://path" for Unix connections</li>
</ul>
<p>The port for TCP/IP and UDP protocols can be <code>0</code> or <code>*</code>, in which case the actual port number is assigned by the system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The target name for the new listener. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The locally resolved listener name. This name can be used to remove the listener later on. </dd></dl>

</div>
</div>
<a class="anchor" id="a99a757fca59ded7fad7021804a5f74aa"></a><!-- doxytag: member="yami::agent::remove_listener" ref="a99a757fca59ded7fad7021804a5f74aa" args="(const std::string &amp;listener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void agent::remove_listener </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes the listener denoted by its actual target name. Note that the actual target name might be different from the name provided when the listener was created, due to target resolution. The name which should be used for listener removal is the name that is returned by the <code>add_listener</code> function. </p>

</div>
</div>
<a class="anchor" id="a031b46c55b480ebb62eaba0ee521aaba"></a><!-- doxytag: member="yami::agent::register_object" ref="a031b46c55b480ebb62eaba0ee521aaba" args="(const std::string &amp;object_name, functor &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yami::agent::register_object </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">functor &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Registers the new "object" that can be a logical destination for incoming messages.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object_name</td><td>The name of the newly registered object. If an object with this name is already registered, the registration data is replaced. </td></tr>
    <tr><td class="paramname">f</td><td>The callable entity that can accept the <code><a class="el" href="classyami_1_1incoming__message.html" title="Incoming message.">incoming_message</a></code> as the invocation parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e2db2c61d13c7ba9db6bd0078b49c8e"></a><!-- doxytag: member="yami::agent::register_value_publisher" ref="a4e2db2c61d13c7ba9db6bd0078b49c8e" args="(const std::string &amp;object_name, value_publisher &amp;publisher)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void agent::register_value_publisher </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyami_1_1value__publisher.html">value_publisher</a> &amp;&#160;</td>
          <td class="paramname"><em>publisher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object_name</td><td>The name of the newly registered object. If an object with this name is already registered, the registration data is replaced. </td></tr>
    <tr><td class="paramname">publisher</td><td>The value publisher to be registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad43d2ef6c6977d053369bb2ed8d5610e"></a><!-- doxytag: member="yami::agent::unregister_object" ref="ad43d2ef6c6977d053369bb2ed8d5610e" args="(const std::string &amp;object_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void agent::unregister_object </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>It is permitted to request unregistration for an object that does not exist - such operation has no effect.</p>
<p><b>Note:</b> Due to performance and design tradeoffs it is <b>not</b> guaranteed that no more messages will be ever dispatched to the given object when this function returns. In fact, some of the messages that have been received by agent and not yet dispatched might be still dispatched shortly after this function returns. Only those messages that are received by agent after this function returns are guaranteed not to be dispatched to the unregistered object. This might be particularly important with regard to the lifetime of the callable entity that was provided when the given object has been registered.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object_name</td><td>The name of the object to be unregistered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb8ff8baef4521d7c694a09f9e7a844a"></a><!-- doxytag: member="yami::agent::open_connection" ref="adb8ff8baef4521d7c694a09f9e7a844a" args="(const std::string &amp;target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void agent::open_connection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opens the new channel or does nothing if the channel already exists.</p>
<p>This function is not necessary with automatic connection recovery option in <code>send</code> and <code>send_one_way</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The name of the target endpoint. This name should correspond to the listener name in some target agent object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5cf1f567dcc83fe784387b849d7003ad"></a><!-- doxytag: member="yami::agent::open_connection" ref="a5cf1f567dcc83fe784387b849d7003ad" args="(const std::string &amp;target, const parameters &amp;options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void agent::open_connection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyami_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opens the new channel or does nothing if the channel already exists. If the new channel is created, it will use the overriding options from those which are defined.</p>
<p>This function is not necessary with automatic connection recovery option in <code>send</code> and <code>send_one_way</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The name of the target endpoint. This name should correspond to the listener name in some target agent object. </td></tr>
    <tr><td class="paramname">options</td><td>The set of options that will override agent's values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03dd5bb46dff202f7cf81e8fc6760366"></a><!-- doxytag: member="yami::agent::send" ref="a03dd5bb46dff202f7cf81e8fc6760366" args="(const std::string &amp;target, const std::string &amp;object_name, const std::string &amp;message_name, const serializable &amp;content=parameters(), std::size_t priority=0, bool auto_connect=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt; <a class="el" href="classyami_1_1outgoing__message.html">outgoing_message</a> &gt; agent::send </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyami_1_1serializable.html">serializable</a> &amp;&#160;</td>
          <td class="paramname"><em>content</em> = <code><a class="el" href="classyami_1_1parameters.html">parameters</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_connect</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends the new outgoing message to the given destination.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The name of the target endpoint. This name should correspond to the listener name in some target agent object. </td></tr>
    <tr><td class="paramname">object_name</td><td>The name of the logical destination object in the target agent. </td></tr>
    <tr><td class="paramname">message_name</td><td>The name of the message. </td></tr>
    <tr><td class="paramname">content</td><td>The content of the message. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the message. </td></tr>
    <tr><td class="paramname">auto_connect</td><td>The flag controlling automatic (re)connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <code><a class="el" href="classyami_1_1outgoing__message.html" title="Outgoing message.">outgoing_message</a></code> object that allows to track the progress of this message, its status and obtain response data.</dd></dl>
<p><b>Note:</b> This function implicitly opens a new communication channel if it is not already open. This channel is kept open until it is explicitly closed (see the <code>close_connection</code> function) or until the agent is destroyed or the communication error is detected. </p>

</div>
</div>
<a class="anchor" id="a4645cf70fa85ead4f35f5619033918ed"></a><!-- doxytag: member="yami::agent::send" ref="a4645cf70fa85ead4f35f5619033918ed" args="(outgoing_message &amp;message, const std::string &amp;target, const std::string &amp;object_name, const std::string &amp;message_name, const serializable &amp;content=parameters(), std::size_t priority=0, bool auto_connect=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void agent::send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyami_1_1outgoing__message.html">outgoing_message</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyami_1_1serializable.html">serializable</a> &amp;&#160;</td>
          <td class="paramname"><em>content</em> = <code><a class="el" href="classyami_1_1parameters.html">parameters</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_connect</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends the outgoing message to the given destination and reinitializes the message object in-place.</p>
<p>This function behaves as the other version of send, except for the <a class="el" href="classyami_1_1outgoing__message.html" title="Outgoing message.">outgoing_message</a> object creation policy. </p>

</div>
</div>
<a class="anchor" id="ac158f696cb51075812aeb0bbdbcc9594"></a><!-- doxytag: member="yami::agent::send" ref="ac158f696cb51075812aeb0bbdbcc9594" args="(functor &amp;f, const std::string &amp;target, const std::string &amp;object_name, const std::string &amp;message_name, const serializable &amp;content=parameters(), std::size_t priority=0, bool auto_connect=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyami_1_1agent.html#a66a2581eed6c243400a1a4ea1d980a8d">outgoing_message_id</a> yami::agent::send </td>
          <td>(</td>
          <td class="paramtype">functor &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyami_1_1serializable.html">serializable</a> &amp;&#160;</td>
          <td class="paramname"><em>content</em> = <code><a class="el" href="classyami_1_1parameters.html">parameters</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_connect</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends the outgoing message to the given destination and executes the callback whenever the status of the message changes. The callback should accept the <a class="el" href="classyami_1_1outgoing__message.html" title="Outgoing message.">outgoing_message</a> object as its parameter. Note: the callback should not block the processing unnecessarily.</p>
<p>This function behaves as the other version of send, except for the <a class="el" href="classyami_1_1outgoing__message.html" title="Outgoing message.">outgoing_message</a> object creation policy. </p>

</div>
</div>
<a class="anchor" id="a31b1b95bb891759b7048bb1c04a9da37"></a><!-- doxytag: member="yami::agent::clean_outgoing_message_callback" ref="a31b1b95bb891759b7048bb1c04a9da37" args="(outgoing_message_id id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool agent::clean_outgoing_message_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyami_1_1agent.html#a66a2581eed6c243400a1a4ea1d980a8d">outgoing_message_id</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cleans internal resources associated with the given message callback.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Outgoing message identifier, as obtained from send. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if the operation could not be completed due to hazard with the already pending callback </dd></dl>

</div>
</div>
<a class="anchor" id="a6ec63dc6cde0b6c996e5568a043c11df"></a><!-- doxytag: member="yami::agent::send_one_way" ref="a6ec63dc6cde0b6c996e5568a043c11df" args="(const std::string &amp;target, const std::string &amp;object_name, const std::string &amp;message_name, const serializable &amp;content=parameters(), std::size_t priority=0, bool auto_connect=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void agent::send_one_way </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyami_1_1serializable.html">serializable</a> &amp;&#160;</td>
          <td class="paramname"><em>content</em> = <code><a class="el" href="classyami_1_1parameters.html">parameters</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_connect</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends the new outgoing message to the given destination, without the possibility to track its progress.</p>
<p>See the description and notes for the <code>send</code> function. </p>

</div>
</div>
<a class="anchor" id="a9ae953bcda452d0ed423eceadae711f9"></a><!-- doxytag: member="yami::agent::close_connection" ref="a9ae953bcda452d0ed423eceadae711f9" args="(const std::string &amp;target, std::size_t priority=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void agent::close_connection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Closes the channel identified by name.</p>
<p>The priority allows to properly handle the existing outgoing messages that are waiting in the outgoing queue for transmission. The existing messages with lower priority are abandoned, whereas the existing messages with priority equal or higher to the one provided as parameter are retained in the outgoing queue and are properly pushed for transmission before the channel is physically closed. The channel is closed immediately only if there are no messages waiting in its outgoing queue.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The name of the target endpoint. </td></tr>
    <tr><td class="paramname">priority</td><td>Proprity of the request, respects existing messages in the outgoing queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ba71027935ac808853ff801ebe45551"></a><!-- doxytag: member="yami::agent::register_connection_event_monitor" ref="a1ba71027935ac808853ff801ebe45551" args="(functor &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yami::agent::register_connection_event_monitor </td>
          <td>(</td>
          <td class="paramtype">functor &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Registers the monitor for connection events.</p>
<p><b>Note:</b> The monitor callback is intentionally not synchronized. Use this function after constructing the agent, but before opening any connections.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The callable entity that can accept the <code>std::string</code> as the connection name and <code>connection_event</code> as event description. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2768b563f95f90aab00e59b1c9d1a029"></a><!-- doxytag: member="yami::agent::register_io_error_logger" ref="a2768b563f95f90aab00e59b1c9d1a029" args="(functor &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yami::agent::register_io_error_logger </td>
          <td>(</td>
          <td class="paramtype">functor &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Registers the logger for I/O errors.</p>
<p><b>Note:</b> The logger callback is intentionally not synchronized. Use this function after constructing the agent, but before opening any connections.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The callable entity that can accept the <code>int</code> as the error code and <code>const char *</code> as error description. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1073b18617073dc36e991b03fd20ada"></a><!-- doxytag: member="yami::agent::get_outgoing_flow_state" ref="ab1073b18617073dc36e991b03fd20ada" args="(std::size_t &amp;current_level, std::size_t &amp;high_water_mark, std::size_t &amp;low_water_mark) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void agent::get_outgoing_flow_state </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>current_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>high_water_mark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>low_water_mark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Obtains the state of overall outgoing flow.</p>
<p><b>Note:</b> The outgoing flow is a combination of all outgoing traffic, and is not tied to any particular communication channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">current_level</td><td>The current level of the outgoing flow. </td></tr>
    <tr><td class="paramname">high_water_mark</td><td>The high water mark. </td></tr>
    <tr><td class="paramname">low_water_mark</td><td>The low water mark. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af4e84cd9c30d75a7ddc44bef2068dfb4"></a><!-- doxytag: member="yami::agent::get_channel_usage" ref="af4e84cd9c30d75a7ddc44bef2068dfb4" args="(int &amp;max_allowed, int &amp;used)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void agent::get_channel_usage </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>max_allowed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>used</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Note:</b> The information obtained with this function can be in constant flow, as incoming and outgoing channels are created and closed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">max_allowed</td><td>The maximum number of channels that the agent can handle internall or 0 if the limit is unknown. </td></tr>
    <tr><td class="paramname">used</td><td>Total number of handled channels and listeners. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceyami.html">yami</a>      </li>
      <li class="navelem"><a class="el" href="classyami_1_1agent.html">agent</a>      </li>

    <li class="footer">Generated on Tue Aug 6 2013 22:41:16 for YAMI4 - C++ general-purpose interface by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
