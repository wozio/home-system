<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>YAMI4 - C++ general-purpose interface: yami::parameters Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">YAMI4 - C++ general-purpose interface
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classyami_1_1parameters.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">yami::parameters Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="yami::parameters" --><!-- doxytag: inherits="yami::serializable" -->
<p>Collection of message parameters.  
 <a href="classyami_1_1parameters.html#details">More...</a></p>

<p><code>#include &lt;parameters.h&gt;</code></p>

<p>Inherits <a class="el" href="classyami_1_1serializable.html">yami::serializable</a>.</p>

<p><a href="classyami_1_1parameters-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters_1_1iterator.html">iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator class for inspecting entries in the collection.  <a href="classyami_1_1parameters_1_1iterator.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a2e2af680388704e90c6c0ceb0edc6cd5">parameters</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a2e2af680388704e90c6c0ceb0edc6cd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a54c4039fa6c590b0b9321e329082c382">parameters</a> (core::parameters *external)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a54c4039fa6c590b0b9321e329082c382"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbdfc73054285aa0f972d0776691ebf8"></a><!-- doxytag: member="yami::parameters::parameters" ref="afbdfc73054285aa0f972d0776691ebf8" args="(const parameters &amp;other)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#afbdfc73054285aa0f972d0776691ebf8">parameters</a> (const <a class="el" href="classyami_1_1parameters.html">parameters</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62ce3de9614d9c6468023d3ef93da048"></a><!-- doxytag: member="yami::parameters::operator=" ref="a62ce3de9614d9c6468023d3ef93da048" args="(const parameters &amp;other)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a62ce3de9614d9c6468023d3ef93da048">operator=</a> (const <a class="el" href="classyami_1_1parameters.html">parameters</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#abfe03d66fca118070b259f745f11407d">swap</a> (<a class="el" href="classyami_1_1parameters.html">parameters</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap operation.  <a href="#abfe03d66fca118070b259f745f11407d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#aa6d3fadb0bf04147d3dae38720c66165">~parameters</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#aa6d3fadb0bf04147d3dae38720c66165"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a1e9eed96e2ca7c33bce8d88d91b72283">set_boolean</a> (const std::string &amp;name, bool value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type bool.  <a href="#a1e9eed96e2ca7c33bce8d88d91b72283"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a7d0526fcb7e1c61e40261717ceefc949">get_boolean</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the bool value from the given entry.  <a href="#a7d0526fcb7e1c61e40261717ceefc949"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#ae56db356cbd8baa37b86abd69bfd4ad8">set_integer</a> (const std::string &amp;name, int value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type int.  <a href="#ae56db356cbd8baa37b86abd69bfd4ad8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#afa622327234643ff2290790ab0a2bb2e">get_integer</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the int value from the given entry.  <a href="#afa622327234643ff2290790ab0a2bb2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a262510d65e26b16eca7bc36ef8ee4434">set_long_long</a> (const std::string &amp;name, long long value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type long long.  <a href="#a262510d65e26b16eca7bc36ef8ee4434"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a38fc28c68463c741d25a4c13ac520e22">get_long_long</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the long long value from the given entry.  <a href="#a38fc28c68463c741d25a4c13ac520e22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#aeb42efc167da0bdf70fa4145a2a20b4d">set_double_float</a> (const std::string &amp;name, double value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type double.  <a href="#aeb42efc167da0bdf70fa4145a2a20b4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a82c2305643b7dbc9d7c639931d7be018">get_double_float</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the double value from the given entry.  <a href="#a82c2305643b7dbc9d7c639931d7be018"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a9f54cc37e5f1247f4d87530699cfb054">set_string</a> (const std::string &amp;name, const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type string.  <a href="#a9f54cc37e5f1247f4d87530699cfb054"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#ac10211f02b96fc3884ca98f4eefc489a">set_string_shallow</a> (const std::string &amp;name, const char *value, std::size_t value_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type string.  <a href="#ac10211f02b96fc3884ca98f4eefc489a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#aab48d7633520c2c6b318abad8cd9d864">get_string</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the string value from the given entry.  <a href="#aab48d7633520c2c6b318abad8cd9d864"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a012ff5d274dc8b83e8c8ac439ec045b0">get_string</a> (const std::string &amp;name, std::size_t &amp;length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the string value from the given entry.  <a href="#a012ff5d274dc8b83e8c8ac439ec045b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a7ca53a7fde26eb617b10a65fd5330f62">set_binary</a> (const std::string &amp;name, const void *value, std::size_t value_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type binary.  <a href="#a7ca53a7fde26eb617b10a65fd5330f62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a917570750b9dcd3f0d53263ab6a62d95">set_binary_shallow</a> (const std::string &amp;name, const void *value, std::size_t value_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type binary.  <a href="#a917570750b9dcd3f0d53263ab6a62d95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#ac7fb4bbe1d8ba7fdb1382f3b4ef5ae5e">get_binary</a> (const std::string &amp;name, std::size_t &amp;length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the binary value from the given entry.  <a href="#ac7fb4bbe1d8ba7fdb1382f3b4ef5ae5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#ad4960c5d7752eda29fe2b6dcd882d1c3">set_boolean_array</a> (const std::string &amp;name, const bool *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type bool array.  <a href="#ad4960c5d7752eda29fe2b6dcd882d1c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a21101e349b0b981280fc51cfb3d1a464">set_boolean_array_shallow</a> (const std::string &amp;name, const bool *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type bool array.  <a href="#a21101e349b0b981280fc51cfb3d1a464"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#ae69c800c0f18c4de86a9dd6d09531800">get_boolean_array</a> (const std::string &amp;name, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the array of bool values from the given entry.  <a href="#ae69c800c0f18c4de86a9dd6d09531800"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a5def3cd35529f87e081474250d85e0e8">set_integer_array</a> (const std::string &amp;name, const int *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type int array.  <a href="#a5def3cd35529f87e081474250d85e0e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#ad002f74e9955cefaf1979e397e399d5c">set_integer_array_shallow</a> (const std::string &amp;name, const int *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type int array.  <a href="#ad002f74e9955cefaf1979e397e399d5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a030fa1aa67f46e138b993fe5fba7fd42">get_integer_array</a> (const std::string &amp;name, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the array of int values from the given entry.  <a href="#a030fa1aa67f46e138b993fe5fba7fd42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a2fe68d1560852154a0553351720293ea">set_long_long_array</a> (const std::string &amp;name, const long long *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type long long array.  <a href="#a2fe68d1560852154a0553351720293ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#ae43fbe826c4ea853c441ec0438651c6f">set_long_long_array_shallow</a> (const std::string &amp;name, const long long *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type long long array.  <a href="#ae43fbe826c4ea853c441ec0438651c6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long long *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a29d0d049ddc9eff031f30046fe9b5a1e">get_long_long_array</a> (const std::string &amp;name, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the array of long long values from the given entry.  <a href="#a29d0d049ddc9eff031f30046fe9b5a1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a027807148d0bc47c678dcb9e6efa5f06">set_double_float_array</a> (const std::string &amp;name, const double *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type double array.  <a href="#a027807148d0bc47c678dcb9e6efa5f06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a12c918b2b8d19acb52c8a99112be6adc">set_double_float_array_shallow</a> (const std::string &amp;name, const double *values, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entry of type double array.  <a href="#a12c918b2b8d19acb52c8a99112be6adc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a481c551599f01b7e53fca8761a017af4">get_double_float_array</a> (const std::string &amp;name, std::size_t &amp;array_length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the array of double values from the given entry.  <a href="#a481c551599f01b7e53fca8761a017af4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a8a9854ae36e991bec481410e5a32d6a8">create_string_array</a> (const std::string &amp;name, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new empty entry of type string array.  <a href="#a8a9854ae36e991bec481410e5a32d6a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a42068e4db7c82c22d149caee77a8d95d">set_string_in_array</a> (const std::string &amp;name, std::size_t index, const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new string value to string array.  <a href="#a42068e4db7c82c22d149caee77a8d95d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#af04f51a14bc19364205eb90fc140256d">get_string_array_length</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the length of string array.  <a href="#af04f51a14bc19364205eb90fc140256d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#add67fb291ccbaf07de826956de536260">get_string_in_array</a> (const std::string &amp;name, std::size_t index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts string value from string array.  <a href="#add67fb291ccbaf07de826956de536260"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#ad6fb32b3b777b0563392e0ae9622bfb8">get_string_in_array</a> (const std::string &amp;name, std::size_t index, std::size_t &amp;length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts string value from string array.  <a href="#ad6fb32b3b777b0563392e0ae9622bfb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a225f01d06aeb45c2acaf4f42f74bcc45">create_binary_array</a> (const std::string &amp;name, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new empty entry of type binary array.  <a href="#a225f01d06aeb45c2acaf4f42f74bcc45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#aca741e83d6b28bd44434d346a2aacaef">set_binary_in_array</a> (const std::string &amp;name, std::size_t index, const void *value, std::size_t value_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new binary value to binary array.  <a href="#aca741e83d6b28bd44434d346a2aacaef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a70749328052c0af0e965173ccbf89c1e">get_binary_array_length</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the length of binary array.  <a href="#a70749328052c0af0e965173ccbf89c1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#aa7172edf945e2031fc2aa1dc2acf18d3">get_binary_in_array</a> (const std::string &amp;name, std::size_t index, std::size_t &amp;length) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts binary value from binary array.  <a href="#aa7172edf945e2031fc2aa1dc2acf18d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">core::parameters *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#af53d99f6191fe81c2a4bc754f466207f">create_nested_parameters</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates nested parameters entry.  <a href="#af53d99f6191fe81c2a4bc754f466207f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">core::parameters *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a7265c444614ea7bd08913160d81a3475">get_nested_parameters</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the nested parameters object from the given entry.  <a href="#a7265c444614ea7bd08913160d81a3475"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a773af7f45736e89b70b0a0cc91de053d">create_nested_array</a> (const std::string &amp;name, std::size_t array_length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates nested parameters array entry.  <a href="#a773af7f45736e89b70b0a0cc91de053d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a9dd531b533c333919fef0f5e3ff749ff">get_nested_array_length</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the length of nested parameters array.  <a href="#a9dd531b533c333919fef0f5e3ff749ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">core::parameters *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a1a2bece74f551aaeaf3c276e0dffd006">get_nested_in_array</a> (const std::string &amp;name, std::size_t index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts nested parameters value from nested array.  <a href="#a1a2bece74f551aaeaf3c276e0dffd006"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a1b53aa1d01977889db4bff9159f8589a">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the collection.  <a href="#a1b53aa1d01977889db4bff9159f8589a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyami.html#a4e80fb2c25762c4bfd4568caade24ecc">parameter_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#ac1732d120a041ce8a6bea5d6c1058891">type</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the type of the given entry.  <a href="#ac1732d120a041ce8a6bea5d6c1058891"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyami_1_1parameters_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#affaa7196ae05ead400158bf85f85ecd3">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the starting iterator for this collection.  <a href="#affaa7196ae05ead400158bf85f85ecd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyami_1_1parameters_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#aaceee1c8907d62ebde6a4b95fc7a094d">end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the ending iterator for this collection.  <a href="#aaceee1c8907d62ebde6a4b95fc7a094d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a9ff0490eb23c07f193696dbaf5f22cef">find</a> (const std::string &amp;name, <a class="el" href="classyami_1_1parameter__entry.html">parameter_entry</a> &amp;entry) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the given entry.  <a href="#a9ff0490eb23c07f193696dbaf5f22cef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#ab1eb99f607e6ac28af7bf7daa87f7f8b">remove</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given entry.  <a href="#ab1eb99f607e6ac28af7bf7daa87f7f8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a86c3c3ee8b8f89f96ab05db1e579bcdc">remove</a> (<a class="el" href="classyami_1_1parameters_1_1iterator.html">iterator</a> it)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the entry given by its iterator.  <a href="#a86c3c3ee8b8f89f96ab05db1e579bcdc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a1b9d6b0e94c23a6143dc6f8aeb00e660">merge_from</a> (const <a class="el" href="classyami_1_1parameters.html">parameters</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges entries from the given parameters object.  <a href="#a1b9d6b0e94c23a6143dc6f8aeb00e660"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a893060f7227a52e9fa9f459b30045773">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the collection of entries.  <a href="#a893060f7227a52e9fa9f459b30045773"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a5ab74ed3f152375a3e5eb8cefbc36bcd">serialize_buffer_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total size of serialization buffer.  <a href="#a5ab74ed3f152375a3e5eb8cefbc36bcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#aca93c7e2625a66887fe0767053cc62b9">serialize</a> (char **buffers, std::size_t *buffer_sizes, std::size_t num_of_buffers) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes current content into given buffer(s).  <a href="#aca93c7e2625a66887fe0767053cc62b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a60b8d7d226c5ee7db76239673d997af9">deserialize</a> (const char **buffers, std::size_t *buffer_sizes, std::size_t num_of_buffers)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes from the given buffer(s).  <a href="#a60b8d7d226c5ee7db76239673d997af9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ada9438e99b63aee9b8726c36ba1d64"></a><!-- doxytag: member="yami::parameters::get_core_object" ref="a7ada9438e99b63aee9b8726c36ba1d64" args="() const " -->
virtual const core::parameters &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1parameters.html#a7ada9438e99b63aee9b8726c36ba1d64">get_core_object</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying core object. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The collection of message parameters, which are typed {name, value} pairs.</p>
<p>Each entry in this collection has a unique name and can have one of the following types:</p>
<ul>
<li>bool or bool array</li>
<li>int or int array</li>
<li>long long or long long array</li>
<li>double or double array</li>
<li>string or string array</li>
<li>binary or binary array</li>
<li>nested parameters object, which provides its own scope for naming.</li>
</ul>
<p>This class is not thread-safe, although distinct instances of this class can be used by different threads without synchronization.</p>
<p><b>Note:</b> The entries are <em>ordered</em> - the order in which they are created influences the final serialized form of the message payload.<br/>
 Newly created entries are appended to the end of the collection unless there is an existing empty slot that can be reused - the appropriate slot is searched for from the beginning to the end of the collection and if no free slot is found the collection is extended at the end.<br/>
 The above guarantee concerns the user code that relies on predictable serialization.</p>
<p><b>Note:</b> For each function that accepts <code>const std::string &amp;</code> parameter there is also an overloaded function accepting <code>const char *</code>. These additional functions are provided to make it more natural to use strings by pointer or as a hard-code literals. They have exactly the same functionality and are therefore not separately documented. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2e2af680388704e90c6c0ceb0edc6cd5"></a><!-- doxytag: member="yami::parameters::parameters" ref="a2e2af680388704e90c6c0ceb0edc6cd5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parameters::parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates an empty parameters object. </p>

</div>
</div>
<a class="anchor" id="a54c4039fa6c590b0b9321e329082c382"></a><!-- doxytag: member="yami::parameters::parameters" ref="a54c4039fa6c590b0b9321e329082c382" args="(core::parameters *external)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parameters::parameters </td>
          <td>(</td>
          <td class="paramtype">core::parameters *&#160;</td>
          <td class="paramname"><em>external</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor, allows to wrap existing object from the core part of the YAMI library. </p>

</div>
</div>
<a class="anchor" id="aa6d3fadb0bf04147d3dae38720c66165"></a><!-- doxytag: member="yami::parameters::~parameters" ref="aa6d3fadb0bf04147d3dae38720c66165" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">yami::parameters::~parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The destructor cleans all dependent resources. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abfe03d66fca118070b259f745f11407d"></a><!-- doxytag: member="yami::parameters::swap" ref="abfe03d66fca118070b259f745f11407d" args="(parameters &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyami_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The (no-throw) swap operation. </p>

</div>
</div>
<a class="anchor" id="a1e9eed96e2ca7c33bce8d88d91b72283"></a><!-- doxytag: member="yami::parameters::set_boolean" ref="a1e9eed96e2ca7c33bce8d88d91b72283" args="(const std::string &amp;name, bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type bool to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d0526fcb7e1c61e40261717ceefc949"></a><!-- doxytag: member="yami::parameters::get_boolean" ref="a7d0526fcb7e1c61e40261717ceefc949" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parameters::get_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the bool value from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of the entry if it has correct type. </dd></dl>

</div>
</div>
<a class="anchor" id="ae56db356cbd8baa37b86abd69bfd4ad8"></a><!-- doxytag: member="yami::parameters::set_integer" ref="ae56db356cbd8baa37b86abd69bfd4ad8" args="(const std::string &amp;name, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_integer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type int to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa622327234643ff2290790ab0a2bb2e"></a><!-- doxytag: member="yami::parameters::get_integer" ref="afa622327234643ff2290790ab0a2bb2e" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int parameters::get_integer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the int value from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of the entry if it has correct type. </dd></dl>

</div>
</div>
<a class="anchor" id="a262510d65e26b16eca7bc36ef8ee4434"></a><!-- doxytag: member="yami::parameters::set_long_long" ref="a262510d65e26b16eca7bc36ef8ee4434" args="(const std::string &amp;name, long long value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_long_long </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type long long to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38fc28c68463c741d25a4c13ac520e22"></a><!-- doxytag: member="yami::parameters::get_long_long" ref="a38fc28c68463c741d25a4c13ac520e22" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long parameters::get_long_long </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the long long value from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of the entry if it has correct type. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb42efc167da0bdf70fa4145a2a20b4d"></a><!-- doxytag: member="yami::parameters::set_double_float" ref="aeb42efc167da0bdf70fa4145a2a20b4d" args="(const std::string &amp;name, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_double_float </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type double to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82c2305643b7dbc9d7c639931d7be018"></a><!-- doxytag: member="yami::parameters::get_double_float" ref="a82c2305643b7dbc9d7c639931d7be018" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double parameters::get_double_float </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the double value from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of the entry if it has correct type. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f54cc37e5f1247f4d87530699cfb054"></a><!-- doxytag: member="yami::parameters::set_string" ref="a9f54cc37e5f1247f4d87530699cfb054" args="(const std::string &amp;name, const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type string to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac10211f02b96fc3884ca98f4eefc489a"></a><!-- doxytag: member="yami::parameters::set_string_shallow" ref="ac10211f02b96fc3884ca98f4eefc489a" args="(const std::string &amp;name, const char *value, std::size_t value_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_string_shallow </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type string to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the value buffer to be set. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">value_length</td><td>Length of the value buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> The value is <em><b>not</b></em> <em>copied</em> to the internal buffer and the user has to ensure that the given buffer is valid as long as this object refers to it. </p>

</div>
</div>
<a class="anchor" id="aab48d7633520c2c6b318abad8cd9d864"></a><!-- doxytag: member="yami::parameters::get_string" ref="aab48d7633520c2c6b318abad8cd9d864" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string parameters::get_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the string value from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of the entry if it has correct type. </dd></dl>

</div>
</div>
<a class="anchor" id="a012ff5d274dc8b83e8c8ac439ec045b0"></a><!-- doxytag: member="yami::parameters::get_string" ref="a012ff5d274dc8b83e8c8ac439ec045b0" args="(const std::string &amp;name, std::size_t &amp;length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * parameters::get_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the string value from the entry given by its name by accessing the buffer directly. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
    <tr><td class="paramname">length</td><td>Length of the internal buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of the entry if it has correct type. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ca53a7fde26eb617b10a65fd5330f62"></a><!-- doxytag: member="yami::parameters::set_binary" ref="a7ca53a7fde26eb617b10a65fd5330f62" args="(const std::string &amp;name, const void *value, std::size_t value_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_binary </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type binary to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be set. </td></tr>
    <tr><td class="paramname">value_length</td><td>Length of the value buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a917570750b9dcd3f0d53263ab6a62d95"></a><!-- doxytag: member="yami::parameters::set_binary_shallow" ref="a917570750b9dcd3f0d53263ab6a62d95" args="(const std::string &amp;name, const void *value, std::size_t value_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_binary_shallow </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type binary to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the value buffer to be set. The buffer can contain zeros. </td></tr>
    <tr><td class="paramname">value_length</td><td>Length of the value buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> The value is <em><b>not</b></em> <em>copied</em> to the internal buffer and the user has to ensure that the given buffer is valid as long as this object refers to it. </p>

</div>
</div>
<a class="anchor" id="ac7fb4bbe1d8ba7fdb1382f3b4ef5ae5e"></a><!-- doxytag: member="yami::parameters::get_binary" ref="ac7fb4bbe1d8ba7fdb1382f3b4ef5ae5e" args="(const std::string &amp;name, std::size_t &amp;length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * parameters::get_binary </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the binary value from the entry given by its name by accessing the buffer directly. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
    <tr><td class="paramname">length</td><td>Length of the internal buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of the entry if it has correct type. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4960c5d7752eda29fe2b6dcd882d1c3"></a><!-- doxytag: member="yami::parameters::set_boolean_array" ref="ad4960c5d7752eda29fe2b6dcd882d1c3" args="(const std::string &amp;name, const bool *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_boolean_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type bool array to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the array of values to be set. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array of values.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> The array of values is <em>copied</em> to the internal buffer. </p>

</div>
</div>
<a class="anchor" id="a21101e349b0b981280fc51cfb3d1a464"></a><!-- doxytag: member="yami::parameters::set_boolean_array_shallow" ref="a21101e349b0b981280fc51cfb3d1a464" args="(const std::string &amp;name, const bool *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_boolean_array_shallow </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type bool array to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the array of values to be set. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array of values.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> The array of values is <em><b>not</b></em> <em>copied</em> to the internal buffer and the user has to ensure that the given buffer is valid as long as this object refers to it. </p>

</div>
</div>
<a class="anchor" id="ae69c800c0f18c4de86a9dd6d09531800"></a><!-- doxytag: member="yami::parameters::get_boolean_array" ref="ae69c800c0f18c4de86a9dd6d09531800" args="(const std::string &amp;name, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool * parameters::get_boolean_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the array of bool values from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the internal array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the internal array buffer.</dd></dl>
<p><b>Note:</b> this function gives read-write access to the underlying array, even if it was set as a shallow-copy. </p>

</div>
</div>
<a class="anchor" id="a5def3cd35529f87e081474250d85e0e8"></a><!-- doxytag: member="yami::parameters::set_integer_array" ref="a5def3cd35529f87e081474250d85e0e8" args="(const std::string &amp;name, const int *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_integer_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type int array to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the array of values to be set. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array of values.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> The array of values is <em>copied</em> to the internal buffer. </p>

</div>
</div>
<a class="anchor" id="ad002f74e9955cefaf1979e397e399d5c"></a><!-- doxytag: member="yami::parameters::set_integer_array_shallow" ref="ad002f74e9955cefaf1979e397e399d5c" args="(const std::string &amp;name, const int *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_integer_array_shallow </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type int array to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the array of values to be set. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array of values.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> The array of values is <em><b>not</b></em> <em>copied</em> to the internal buffer and the user has to ensure that the given buffer is valid as long as this object refers to it. </p>

</div>
</div>
<a class="anchor" id="a030fa1aa67f46e138b993fe5fba7fd42"></a><!-- doxytag: member="yami::parameters::get_integer_array" ref="a030fa1aa67f46e138b993fe5fba7fd42" args="(const std::string &amp;name, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * parameters::get_integer_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the array of int values from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the internal array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the internal array buffer.</dd></dl>
<p><b>Note:</b> this function gives read-write access to the underlying array, even if it was set as a shallow-copy. </p>

</div>
</div>
<a class="anchor" id="a2fe68d1560852154a0553351720293ea"></a><!-- doxytag: member="yami::parameters::set_long_long_array" ref="a2fe68d1560852154a0553351720293ea" args="(const std::string &amp;name, const long long *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_long_long_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type long long array to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the array of values to be set. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array of values.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> The array of values is <em>copied</em> to the internal buffer. </p>

</div>
</div>
<a class="anchor" id="ae43fbe826c4ea853c441ec0438651c6f"></a><!-- doxytag: member="yami::parameters::set_long_long_array_shallow" ref="ae43fbe826c4ea853c441ec0438651c6f" args="(const std::string &amp;name, const long long *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_long_long_array_shallow </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type long long array to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the array of values to be set. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array of values.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> The array of values is <em><b>not</b></em> <em>copied</em> to the internal buffer and the user has to ensure that the given buffer is valid as long as this object refers to it. </p>

</div>
</div>
<a class="anchor" id="a29d0d049ddc9eff031f30046fe9b5a1e"></a><!-- doxytag: member="yami::parameters::get_long_long_array" ref="a29d0d049ddc9eff031f30046fe9b5a1e" args="(const std::string &amp;name, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long * parameters::get_long_long_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the array of long long values from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the internal array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the internal array buffer.</dd></dl>
<p><b>Note:</b> this function gives read-write access to the underlying array, even if it was set as a shallow-copy. </p>

</div>
</div>
<a class="anchor" id="a027807148d0bc47c678dcb9e6efa5f06"></a><!-- doxytag: member="yami::parameters::set_double_float_array" ref="a027807148d0bc47c678dcb9e6efa5f06" args="(const std::string &amp;name, const double *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_double_float_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type double array to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the array of values to be set. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array of values.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> The array of values is <em>copied</em> to the internal buffer. </p>

</div>
</div>
<a class="anchor" id="a12c918b2b8d19acb52c8a99112be6adc"></a><!-- doxytag: member="yami::parameters::set_double_float_array_shallow" ref="a12c918b2b8d19acb52c8a99112be6adc" args="(const std::string &amp;name, const double *values, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_double_float_array_shallow </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new entry of type double array to the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the array of values to be set. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the array of values.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> The array of values is <em><b>not</b></em> <em>copied</em> to the internal buffer and the user has to ensure that the given buffer is valid as long as this object refers to it. </p>

</div>
</div>
<a class="anchor" id="a481c551599f01b7e53fca8761a017af4"></a><!-- doxytag: member="yami::parameters::get_double_float_array" ref="a481c551599f01b7e53fca8761a017af4" args="(const std::string &amp;name, std::size_t &amp;array_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * parameters::get_double_float_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the array of double values from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the internal array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the internally managed array buffer.</dd></dl>
<p><b>Note:</b> this function gives read-write access to the underlying array, even if it was set as a shallow-copy. </p>

</div>
</div>
<a class="anchor" id="a8a9854ae36e991bec481410e5a32d6a8"></a><!-- doxytag: member="yami::parameters::create_string_array" ref="a8a9854ae36e991bec481410e5a32d6a8" args="(const std::string &amp;name, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::create_string_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new empty entry of type string array. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the newly created array.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> After creation the array contains empty strings (that is, strings which length is 0). </p>

</div>
</div>
<a class="anchor" id="a42068e4db7c82c22d149caee77a8d95d"></a><!-- doxytag: member="yami::parameters::set_string_in_array" ref="a42068e4db7c82c22d149caee77a8d95d" args="(const std::string &amp;name, std::size_t index, const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_string_in_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new string value (possibly replacing the old one) to already existing string array at the given index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry containing string array. </td></tr>
    <tr><td class="paramname">index</td><td>The array index (array slot, starting from 0). </td></tr>
    <tr><td class="paramname">value</td><td>Value to be set.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> The value is <em>copied</em> to the internal buffer. </p>

</div>
</div>
<a class="anchor" id="af04f51a14bc19364205eb90fc140256d"></a><!-- doxytag: member="yami::parameters::get_string_array_length" ref="af04f51a14bc19364205eb90fc140256d" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t parameters::get_string_array_length </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the length of string array that is located at the given entry.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry containing string array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Length of the array. </dd></dl>

</div>
</div>
<a class="anchor" id="add67fb291ccbaf07de826956de536260"></a><!-- doxytag: member="yami::parameters::get_string_in_array" ref="add67fb291ccbaf07de826956de536260" args="(const std::string &amp;name, std::size_t index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string parameters::get_string_in_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the string value from the given index of string array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry containing string array. </td></tr>
    <tr><td class="paramname">index</td><td>The array index (array slot to be read, starting from 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value from array. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6fb32b3b777b0563392e0ae9622bfb8"></a><!-- doxytag: member="yami::parameters::get_string_in_array" ref="ad6fb32b3b777b0563392e0ae9622bfb8" args="(const std::string &amp;name, std::size_t index, std::size_t &amp;length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * parameters::get_string_in_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the string value from the given index of string array by accessing the internal buffer directly. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry containing string array. </td></tr>
    <tr><td class="paramname">index</td><td>The array index (array slot to be read, starting from 0). </td></tr>
    <tr><td class="paramname">length</td><td>Length of the value buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value from array. </dd></dl>

</div>
</div>
<a class="anchor" id="a225f01d06aeb45c2acaf4f42f74bcc45"></a><!-- doxytag: member="yami::parameters::create_binary_array" ref="a225f01d06aeb45c2acaf4f42f74bcc45" args="(const std::string &amp;name, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::create_binary_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new empty entry of type binary array. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the newly created array.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> After creation the array contains empty binaries (that is, binaries which length is 0). </p>

</div>
</div>
<a class="anchor" id="aca741e83d6b28bd44434d346a2aacaef"></a><!-- doxytag: member="yami::parameters::set_binary_in_array" ref="aca741e83d6b28bd44434d346a2aacaef" args="(const std::string &amp;name, std::size_t index, const void *value, std::size_t value_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::set_binary_in_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>value_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new binary value (possibly replacing the old one) to already existing binary array at the given index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry containing string array. </td></tr>
    <tr><td class="paramname">index</td><td>The array index (array slot, starting from 0). </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the value buffer to be set. </td></tr>
    <tr><td class="paramname">value_length</td><td>Length of the value buffer.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> The value is <em>copied</em> to the internal buffer. </p>

</div>
</div>
<a class="anchor" id="a70749328052c0af0e965173ccbf89c1e"></a><!-- doxytag: member="yami::parameters::get_binary_array_length" ref="a70749328052c0af0e965173ccbf89c1e" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t parameters::get_binary_array_length </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the length of binary array that is located at the given entry.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry containing binary array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Length of the array. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7172edf945e2031fc2aa1dc2acf18d3"></a><!-- doxytag: member="yami::parameters::get_binary_in_array" ref="aa7172edf945e2031fc2aa1dc2acf18d3" args="(const std::string &amp;name, std::size_t index, std::size_t &amp;length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * parameters::get_binary_in_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the binary value from the given index of binary array by accessing the internal buffer directly. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry containing binary array. </td></tr>
    <tr><td class="paramname">index</td><td>The array index (array slot to be read, starting from 0). </td></tr>
    <tr><td class="paramname">length</td><td>Length of the value buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value from array. </dd></dl>

</div>
</div>
<a class="anchor" id="af53d99f6191fe81c2a4bc754f466207f"></a><!-- doxytag: member="yami::parameters::create_nested_parameters" ref="af53d99f6191fe81c2a4bc754f466207f" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">core::parameters * parameters::create_nested_parameters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new nested parameters entry in the first available slot. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the internally created parameters object; the return value can be used to initialize wrapper <code>parameters</code> object. </dd></dl>

</div>
</div>
<a class="anchor" id="a7265c444614ea7bd08913160d81a3475"></a><!-- doxytag: member="yami::parameters::get_nested_parameters" ref="a7265c444614ea7bd08913160d81a3475" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">core::parameters * parameters::get_nested_parameters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts nested parameters from the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the internally stored parameters object; the return value can be used to initialize wrapper <code>parameters</code> object. </dd></dl>

</div>
</div>
<a class="anchor" id="a773af7f45736e89b70b0a0cc91de053d"></a><!-- doxytag: member="yami::parameters::create_nested_array" ref="a773af7f45736e89b70b0a0cc91de053d" args="(const std::string &amp;name, std::size_t array_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::create_nested_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>array_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new nested parameters array entry. If the entry with the given name already exists it is replaced without changing the order of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the new entry or the entry to be replaced. </td></tr>
    <tr><td class="paramname">array_length</td><td>Length of the newly created array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>ok</code> if operation was successful</li>
<li><code>no_memory</code> if the new entry cannot be allocated</li>
</ul>
</dd></dl>
<p><b>Note:</b> After creation the array contains empty nested objects (that is, parameters objects which do not have any entries). </p>

</div>
</div>
<a class="anchor" id="a9dd531b533c333919fef0f5e3ff749ff"></a><!-- doxytag: member="yami::parameters::get_nested_array_length" ref="a9dd531b533c333919fef0f5e3ff749ff" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t parameters::get_nested_array_length </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the length of nested parameters array that is located at the given entry.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry containing nested parameters array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Length of the array. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a2bece74f551aaeaf3c276e0dffd006"></a><!-- doxytag: member="yami::parameters::get_nested_in_array" ref="a1a2bece74f551aaeaf3c276e0dffd006" args="(const std::string &amp;name, std::size_t index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">core::parameters * parameters::get_nested_in_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the nested parameters value from the given index of nested array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry containing nested parameters array. </td></tr>
    <tr><td class="paramname">index</td><td>The array index (array slot to be read, starting from 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the internally stored parameters object; the return value can be used to initialize wrapper <code>parameters</code> object. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b53aa1d01977889db4bff9159f8589a"></a><!-- doxytag: member="yami::parameters::size" ref="a1b53aa1d01977889db4bff9159f8589a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t parameters::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the size of the collection - that is, the number of all non-empty slots. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size of the collection </dd></dl>

</div>
</div>
<a class="anchor" id="ac1732d120a041ce8a6bea5d6c1058891"></a><!-- doxytag: member="yami::parameters::type" ref="ac1732d120a041ce8a6bea5d6c1058891" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyami.html#a4e80fb2c25762c4bfd4568caade24ecc">parameter_type</a> parameters::type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the type of the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>type of the given entry. </dd></dl>

</div>
</div>
<a class="anchor" id="affaa7196ae05ead400158bf85f85ecd3"></a><!-- doxytag: member="yami::parameters::begin" ref="affaa7196ae05ead400158bf85f85ecd3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyami_1_1parameters_1_1iterator.html">parameters::iterator</a> parameters::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the iterator pointing to the beginning of the collection, which means the first used slot. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the iterator pointing to the beginning of the collection </dd></dl>

</div>
</div>
<a class="anchor" id="aaceee1c8907d62ebde6a4b95fc7a094d"></a><!-- doxytag: member="yami::parameters::end" ref="aaceee1c8907d62ebde6a4b95fc7a094d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyami_1_1parameters_1_1iterator.html">parameters::iterator</a> parameters::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the iterator pointing past the end of the collection. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the iterator pointing past the end of the collection </dd></dl>

</div>
</div>
<a class="anchor" id="a9ff0490eb23c07f193696dbaf5f22cef"></a><!-- doxytag: member="yami::parameters::find" ref="a9ff0490eb23c07f193696dbaf5f22cef" args="(const std::string &amp;name, parameter_entry &amp;entry) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parameters::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyami_1_1parameter__entry.html">parameter_entry</a> &amp;&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extracts the view on the entry specified by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry. </td></tr>
    <tr><td class="paramname">entry</td><td>The entry view to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><code>true</code> if the entry has been found</li>
<li><code>false</code> if the given name cannot be found </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab1eb99f607e6ac28af7bf7daa87f7f8b"></a><!-- doxytag: member="yami::parameters::remove" ref="ab1eb99f607e6ac28af7bf7daa87f7f8b" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::remove </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes the entry given by its name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the entry to remove.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> The removed entry leaves a <em>hole</em> (empty slot) in the collection that can be reused by newly added entries. </p>

</div>
</div>
<a class="anchor" id="a86c3c3ee8b8f89f96ab05db1e579bcdc"></a><!-- doxytag: member="yami::parameters::remove" ref="a86c3c3ee8b8f89f96ab05db1e579bcdc" args="(iterator it)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyami_1_1parameters_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes the entry given by its iterator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Iterator pointing to the entry to remove.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> The removed entry leaves a <em>hole</em> (empty slot) in the collection that can be reused by newly added entries. </p>

</div>
</div>
<a class="anchor" id="a1b9d6b0e94c23a6143dc6f8aeb00e660"></a><!-- doxytag: member="yami::parameters::merge_from" ref="a1b9d6b0e94c23a6143dc6f8aeb00e660" args="(const parameters &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::merge_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyami_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Merges the entries from another parameters object. The merged entries can have the same names, in which case the new entries replace existing ones. The merging is deep in the sense that no data is shared between this and other object after the merge - this applies also to those entries that were shallow references in the other object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to be merged into this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a893060f7227a52e9fa9f459b30045773"></a><!-- doxytag: member="yami::parameters::clear" ref="a893060f7227a52e9fa9f459b30045773" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears the collection of entries and deallocates dependent structures. After executing the state of this object is as it was immediately after construction. </p>

</div>
</div>
<a class="anchor" id="a5ab74ed3f152375a3e5eb8cefbc36bcd"></a><!-- doxytag: member="yami::parameters::serialize_buffer_size" ref="a5ab74ed3f152375a3e5eb8cefbc36bcd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t parameters::serialize_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the total size of serialization buffer(s) for the current content of this object. </p>

<p>Implements <a class="el" href="classyami_1_1serializable.html#a3ff4c34773a07c7fe6ca6c69cecfae95">yami::serializable</a>.</p>

</div>
</div>
<a class="anchor" id="aca93c7e2625a66887fe0767053cc62b9"></a><!-- doxytag: member="yami::parameters::serialize" ref="aca93c7e2625a66887fe0767053cc62b9" args="(char **buffers, std::size_t *buffer_sizes, std::size_t num_of_buffers) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::serialize </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t *&#160;</td>
          <td class="paramname"><em>buffer_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_of_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Serializes the current content of this object into the given buffer(s). The serialization buffer does not have to be contiguous and any number of buffer segments is allowed, provided that the size of each buffer segment is a multiple of 4 (32 bits).<br/>
 The function scatters the serialized data into subsequent buffers as they become filled.<br/>
 The buffers are provided as array of buffer pointers and their sizes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Pointer to the array of buffer pointers (each of type <code>char *</code>). </td></tr>
    <tr><td class="paramname">buffer_sizes</td><td>Pointer to the array of buffer sizes. </td></tr>
    <tr><td class="paramname">num_of_buffers</td><td>Number of buffers described by the array. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classyami_1_1serializable.html#a29d694ca5167abacb275f92c61dbf454">yami::serializable</a>.</p>

</div>
</div>
<a class="anchor" id="a60b8d7d226c5ee7db76239673d997af9"></a><!-- doxytag: member="yami::parameters::deserialize" ref="a60b8d7d226c5ee7db76239673d997af9" args="(const char **buffers, std::size_t *buffer_sizes, std::size_t num_of_buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parameters::deserialize </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t *&#160;</td>
          <td class="paramname"><em>buffer_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_of_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deserializes content from the given buffer(s). The data buffer does not have to be contiguous and any number of buffer segments is allowed, provided that the size of each buffer segment is a multiple of 4 (32 bits).<br/>
 The function gathers the serialized data from subsequent buffers as they are consumed.<br/>
 The buffers are provided as array of buffer pointers and their sizes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Pointer to the array of buffer pointers (each of type <code>const char *</code>). </td></tr>
    <tr><td class="paramname">buffer_sizes</td><td>Pointer to the array of buffer sizes. </td></tr>
    <tr><td class="paramname">num_of_buffers</td><td>Number of buffers described by the array.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> The current content of this object is not cleared before attempting deserialization and each retrieved data element is <em>merged</em> into the current content as if done by individual calls to appropriate <code>set_XYZ</code> functions.<br/>
 In most cases deserialization will be performed to the empty parameters object (to reconstruct it to the form that was used for serialization), but deserialization onto non-empty object might be occasionally useful as a way of merging two collections. </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceyami.html">yami</a>      </li>
      <li class="navelem"><a class="el" href="classyami_1_1parameters.html">parameters</a>      </li>

    <li class="footer">Generated on Tue Aug 6 2013 22:41:16 for YAMI4 - C++ general-purpose interface by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
