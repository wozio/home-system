<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>YAMI4 - C++ general-purpose interface: yami::raw_buffer_data_source Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">YAMI4 - C++ general-purpose interface
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classyami_1_1raw__buffer__data__source.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">yami::raw_buffer_data_source Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="yami::raw_buffer_data_source" --><!-- doxytag: inherits="yami::serializable" -->
<p>Serializable wrapper for the raw binary data.  
 <a href="classyami_1_1raw__buffer__data__source.html#details">More...</a></p>

<p><code>#include &lt;raw_buffer_data_source.h&gt;</code></p>

<p>Inherits <a class="el" href="classyami_1_1serializable.html">yami::serializable</a>.</p>

<p><a href="classyami_1_1raw__buffer__data__source-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1raw__buffer__data__source.html#a0ddcbd61663a8652175471b149ccd611">raw_buffer_data_source</a> (const char **buffers, const std::size_t *buffer_sizes, std::size_t num_of_buffers)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a0ddcbd61663a8652175471b149ccd611"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1raw__buffer__data__source.html#a9ae192c0adbb925bfb0308ed02dd7422">raw_buffer_data_source</a> (const char *buffer, std::size_t buffer_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a9ae192c0adbb925bfb0308ed02dd7422"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1raw__buffer__data__source.html#a299f9e5bc9d66b32d7ac05a263a45852">raw_buffer_data_source</a> (const std::vector&lt; char &gt; &amp;buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a299f9e5bc9d66b32d7ac05a263a45852"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1raw__buffer__data__source.html#a544ea25acccef519263e9c69450ca855">serialize_buffer_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total size of serialization buffer.  <a href="#a544ea25acccef519263e9c69450ca855"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1raw__buffer__data__source.html#ac687f0ad5a2e3284e6f2fac3d02205e3">serialize</a> (char **buffers, std::size_t *buffer_sizes, std::size_t num_of_buffers) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes current content into given buffer(s).  <a href="#ac687f0ad5a2e3284e6f2fac3d02205e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15a803b0b430c788808bf8a6781cddd1"></a><!-- doxytag: member="yami::raw_buffer_data_source::get_core_object" ref="a15a803b0b430c788808bf8a6781cddd1" args="() const " -->
virtual const core::serializable &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyami_1_1raw__buffer__data__source.html#a15a803b0b430c788808bf8a6781cddd1">get_core_object</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying core object. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Serializable wrapper for the raw binary data allows to use already serialized content for message sending. The two major use cases for this class are efficient message forwarding (when the message is received and its content is used for another message) and support for custom data models and serializers. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0ddcbd61663a8652175471b149ccd611"></a><!-- doxytag: member="yami::raw_buffer_data_source::raw_buffer_data_source" ref="a0ddcbd61663a8652175471b149ccd611" args="(const char **buffers, const std::size_t *buffer_sizes, std::size_t num_of_buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_buffer_data_source::raw_buffer_data_source </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t *&#160;</td>
          <td class="paramname"><em>buffer_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_of_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructs the buffer wrapper for the given set of buffers. The data buffer does not have to be contiguous and any number of buffer segments is allowed, provided that the size of each buffer segment is a multiple of 4 (32 bits).<br/>
 The wrapper gathers the binary data from subsequent buffers as they are serialized - serialization of the wrapper copies the data from source set of buffers to the target set, which is possibly structured in a different way.<br/>
 The buffers are provided as array of buffer pointers and their sizes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Pointer to the array of buffer pointers (each of type <code>const char *</code>). </td></tr>
    <tr><td class="paramname">buffer_sizes</td><td>Pointer to the array of buffer sizes. </td></tr>
    <tr><td class="paramname">num_of_buffers</td><td>Number of buffers described by the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ae192c0adbb925bfb0308ed02dd7422"></a><!-- doxytag: member="yami::raw_buffer_data_source::raw_buffer_data_source" ref="a9ae192c0adbb925bfb0308ed02dd7422" args="(const char *buffer, std::size_t buffer_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_buffer_data_source::raw_buffer_data_source </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructs the buffer wrapper for the single contiguous source buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to the source buffer. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>Source buffer size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a299f9e5bc9d66b32d7ac05a263a45852"></a><!-- doxytag: member="yami::raw_buffer_data_source::raw_buffer_data_source" ref="a299f9e5bc9d66b32d7ac05a263a45852" args="(const std::vector&lt; char &gt; &amp;buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_buffer_data_source::raw_buffer_data_source </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructs the buffer wrapper for the single contiguous source buffer, which is given as a vector&lt;char&gt;. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Source buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a544ea25acccef519263e9c69450ca855"></a><!-- doxytag: member="yami::raw_buffer_data_source::serialize_buffer_size" ref="a544ea25acccef519263e9c69450ca855" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t raw_buffer_data_source::serialize_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the total size of serialization buffer(s) for the current content of this object. </p>

<p>Implements <a class="el" href="classyami_1_1serializable.html#a3ff4c34773a07c7fe6ca6c69cecfae95">yami::serializable</a>.</p>

</div>
</div>
<a class="anchor" id="ac687f0ad5a2e3284e6f2fac3d02205e3"></a><!-- doxytag: member="yami::raw_buffer_data_source::serialize" ref="ac687f0ad5a2e3284e6f2fac3d02205e3" args="(char **buffers, std::size_t *buffer_sizes, std::size_t num_of_buffers) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void raw_buffer_data_source::serialize </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t *&#160;</td>
          <td class="paramname"><em>buffer_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_of_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Serializes the current content of this object into the given buffer(s). The serialization buffer does not have to be contiguous and any number of buffer segments is allowed, provided that the size of each buffer segment is a multiple of 4 (32 bits).<br/>
 The function scatters the serialized data into subsequent buffers as they become filled.<br/>
 The buffers are provided as array of buffer pointers and their sizes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Pointer to the array of buffer pointers (each of type <code>char *</code>). </td></tr>
    <tr><td class="paramname">buffer_sizes</td><td>Pointer to the array of buffer sizes. </td></tr>
    <tr><td class="paramname">num_of_buffers</td><td>Number of buffers described by the array. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classyami_1_1serializable.html#a29d694ca5167abacb275f92c61dbf454">yami::serializable</a>.</p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceyami.html">yami</a>      </li>
      <li class="navelem"><a class="el" href="classyami_1_1raw__buffer__data__source.html">raw_buffer_data_source</a>      </li>

    <li class="footer">Generated on Tue Aug 6 2013 22:41:16 for YAMI4 - C++ general-purpose interface by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
